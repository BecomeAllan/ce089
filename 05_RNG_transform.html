<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Walmes M. Zeviani e Fernando P. Mayer" />


<title>Geração de números não uniformes</title>

<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-66454501-13"></script>
<script>
 window.dataLayer = window.dataLayer || [];
 function gtag(){dataLayer.push(arguments);}
 gtag('js', new Date());

 gtag('config', 'UA-66454501-13');
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>





<link rel="stylesheet" href="default" type="text/css" />
<link rel="stylesheet" href="config/sydney-site.css" type="text/css" />
<link rel="stylesheet" href="config/sydney-site-fonts.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}

.tocify-subheader {
  display: inline;
}
.tocify-subheader .tocify-item {
  font-size: 0.95em;
}

</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">CE089</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="aulas.html">Aulas</a>
</li>
<li>
  <a href="referencias.html">Referências</a>
</li>
<li>
  <a href="materiais.html">Materiais</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/leg-ufpr/ce089">
    <span class="fab fa-github"></span>
     
    GitHub
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Geração de números não uniformes</h1>
<h3 class="subtitle">Método da transformação de variáveis</h3>
<h4 class="author">Walmes M. Zeviani e Fernando P. Mayer</h4>

</div>


<div id="introdução" class="section level1">
<h1><span class="header-section-number">1</span> Introdução</h1>
<p>A ideia do método da transformação de variáveis é gerar valores aleatórios de uma distribuição qualquer, com base na relação com alguma outra distribuição conhecida. Portanto, primeiro gera-se valores de uma distribuição da qual se conhece e que possua um bom gerador disponível. Depois disso, basta aplicar a transformação para se chegar nos valores da distribuição desejada.</p>
<p>Um exemplo típico é, por exemplo, quando queremos gerar valores de uma distribuição <span class="math inline">\(\text{logN}(\mu, \sigma^2)\)</span> a partir de valores gerados de uma <span class="math inline">\(\text{N}(\mu, \sigma^2)\)</span>. Nesse caso, se <span class="math inline">\(Y \sim \text{N}(\mu, \sigma^2)\)</span>, então usando a transformação <span class="math inline">\(X = e^{Y}\)</span>, <span class="math inline">\(X\)</span> terá distribuição <span class="math inline">\(\text{logN}(\mu, \sigma^2)\)</span>, pois <span class="math inline">\(\log X = Y\)</span>.</p>
<p>Para um diagrama completo (ou quase) da relação entre distribuições univariadas, veja <a href="http://www.math.wm.edu/~leemis/chart/UDR/UDR.html">Univariate Distribution Relationships</a> de Lawrence Leemis.</p>
</div>
<div id="exemplos-de-transformações" class="section level1">
<h1><span class="header-section-number">2</span> Exemplos de transformações</h1>
<p>Alguns exemplos são:</p>
<ol style="list-style-type: decimal">
<li>Se <span class="math inline">\(Z \sim \text{N}(0,1)\)</span>, então <span class="math inline">\(V=Z^2 \sim \chi^2(1)\)</span></li>
<li>Se <span class="math inline">\(U \sim \chi^2(m)\)</span> e <span class="math inline">\(V \sim \chi^2(n)\)</span> são independentes, então <span class="math inline">\(F = \frac{U/m}{V/n}\)</span> terá a distribuição <span class="math inline">\(F\)</span> com <span class="math inline">\((m,n)\)</span> graus de liberdade.</li>
<li>Se <span class="math inline">\(Z \sim \text{N}(0,1)\)</span> e <span class="math inline">\(V \sim \chi^2(n)\)</span> são independentes, então <span class="math inline">\(T = \frac{Z}{\sqrt{V/n}}\)</span> terá a distribuição <span class="math inline">\(t\)</span> de Student com <span class="math inline">\(n\)</span> graus de liberdade.</li>
<li>Se <span class="math inline">\(U_1, \ldots, U_{12} \sim \text{U}(-1/2,1/2)\)</span>, então <span class="math inline">\(Z = \sum_{i=1}^{12} U_i\)</span> terá distribuição <span class="math inline">\(\text{N}(0,1)\)</span> (usando o <strong>Teorema do Limite Central</strong>).</li>
<li>Se <span class="math inline">\(U, V \sim \text{U}(0,1)\)</span> são independentes, então <span class="math display">\[
Z_1 = \sqrt{-2 \log U} \cos (2\pi V) \qquad
Z_2 = \sqrt{-2 \log U} \sin (2\pi V)
\]</span> serão duas VAs <strong>independentes</strong> com distribuição normal padrão.</li>
<li>Se <span class="math inline">\(U \sim \text{Gama}(r,\lambda)\)</span> e <span class="math inline">\(V \sim \text{Gama}(s,\lambda)\)</span> são independentes, então <span class="math inline">\(X = \frac{U}{U+V}\)</span> terá a distribuição <span class="math inline">\(\text{Beta}(r, s)\)</span>.</li>
<li>Se <span class="math inline">\(U, V \sim \text{U}(0,1)\)</span> são independentes, então <span class="math display">\[
X = \left\lfloor 1 + \frac{\log (V)}{\log (1 - (1 - \theta)^U)}
\right\rfloor
\]</span> terá a distribuição <span class="math inline">\(\text{Logaritmica}(\theta)\)</span>, onde <span class="math inline">\(\lfloor x \rfloor\)</span> denota a parte inteira (arredondada para baixo) de <span class="math inline">\(x\)</span>.</li>
<li><span class="math inline">\(U \sim \text{U}(0,1)\)</span>, então <span class="math inline">\(X = -\lambda \log U\)</span> terá distribuição <span class="math inline">\(\text{Exp}(\lambda)\)</span>.</li>
</ol>
<p><strong>Somas</strong> e <strong>misturas</strong> de distribuições são considerados tipos especiais de transformações.</p>
<p>Veremos algumas implementações abaixo.</p>
<div id="exemplo-distribuição-beta" class="section level2">
<h2><span class="header-section-number">2.1</span> Exemplo (distribuição Beta)</h2>
<p>Se <span class="math inline">\(U \sim \text{Gama}(r,\lambda)\)</span> e <span class="math inline">\(V \sim \text{Gama}(s,\lambda)\)</span> são independentes, então <span class="math display">\[
X = \frac{U}{U+V}
\]</span> terá a distribuição <span class="math inline">\(\text{Beta}(r, s)\)</span>.</p>
<ol style="list-style-type: decimal">
<li>Gere um valor aleatório <span class="math inline">\(u\)</span> de <span class="math inline">\(\text{Gama}(r, 1)\)</span></li>
<li>Gere um valor aleatório <span class="math inline">\(v\)</span> de <span class="math inline">\(\text{Gama}(s, 1)\)</span></li>
<li>Calcule <span class="math inline">\(x = \dfrac{u}{u+v}\)</span></li>
</ol>
<p>Para gerar valores de uma <span class="math inline">\(\text{Beta}(3,2)\)</span> fazemos então:</p>
<pre class="r"><code>n &lt;- 1000
r &lt;- 3
s &lt;- 2
u &lt;- rgamma(n, shape = r, rate = 1)
v &lt;- rgamma(n, shape = s, rate = 1)
x &lt;- u/(u + v)
## Comparação
par(mfrow = c(1, 2))
plot(ecdf(x))
curve(pbeta(x, r, s), add = TRUE, col = 2)
q &lt;- qbeta(ppoints(n), r, s)
qqplot(q, x)
abline(0, 1, col = 2)
par(mfrow = c(1, 1))</code></pre>
<p><img src="figures/05_RNG_transform/unnamed-chunk-2-1.png" width="80%" style="display: block; margin: auto;" /></p>
</div>
<div id="exemplo-distribuição-logarítmica" class="section level2">
<h2><span class="header-section-number">2.2</span> Exemplo (distribuição Logarítmica)</h2>
<p>(Este é um exemplo de uma distribuição onde não existe uma função pronta no R para gerar valores).</p>
<p>Dizemos que <span class="math inline">\(X\)</span> segue a distribuição (discreta) Logarítmica se <span class="math display">\[
f(x) = P[X=x] = \frac{a \theta^x}{x}, \quad x=1, 2, \ldots
\]</span> onde <span class="math inline">\(0 &lt; \theta &lt; 1\)</span> e <span class="math inline">\(a = (-\log (1-\theta))^{-1}\)</span>.</p>
<p>Se <span class="math inline">\(U, V \sim \text{U}(0,1)\)</span> são independentes, então <span class="math display">\[
X = \left\lfloor 1 + \frac{\log (V)}{\log (1 - (1 - \theta)^U)}
\right\rfloor
\]</span> terá a distribuição <span class="math inline">\(\text{Logaritmica}(\theta)\)</span>.</p>
<ol style="list-style-type: decimal">
<li>Gere um valor aleatório <span class="math inline">\(u\)</span> de <span class="math inline">\(\text{U}(0, 1)\)</span></li>
<li>Gere um valor aleatório <span class="math inline">\(v\)</span> de <span class="math inline">\(\text{U}(0, 1)\)</span></li>
<li>Calcule <span class="math inline">\(x = \left\lfloor 1 + \frac{\log (v)}{\log (1 - (1 - \theta)^u)} \right\rfloor\)</span></li>
</ol>
<p>Para gerar valores de uma <span class="math inline">\(\text{Logaritmica}(0.5)\)</span> fazemos então</p>
<pre class="r"><code>n &lt;- 1000
theta &lt;- 0.5
u &lt;- runif(n)
v &lt;- runif(n)
x &lt;- floor(1 + log(v) / log(1 - (1 - theta)^u))
## Calcula as probabilidades teóricas (exatas) usando a definição da
## distribuição
k &lt;- 1:max(x)
p &lt;- -1/log(1 - theta) * theta^k/k
## Compara a proporção de valores gerados com a prob. teórica
cbind(&quot;Gerado&quot; = prop.table(table(x)), &quot;Teórico&quot; = p)</code></pre>
<pre><code>#   Gerado     Teórico
# 1  0.738 0.721347520
# 2  0.155 0.180336880
# 3  0.062 0.060112293
# 4  0.023 0.022542110
# 5  0.012 0.009016844
# 6  0.008 0.003757018
# 7  0.002 0.001610151</code></pre>
<pre class="r"><code>## Comparação gráfica
par(mfrow = c(1, 2))
plot(prop.table(table(x)), xlab = &quot;X&quot;, ylab = &quot;P[X]&quot;)
points(p ~ I(k + 0.1), type = &quot;h&quot;, col = 2, lwd = 2)
legend(&quot;topright&quot;, legend = c(&quot;Empírico&quot;, &quot;Teórico&quot;),
       lty = 1, col = c(1, 2))
plot(ecdf(x))
lines(cumsum(p), type = &quot;s&quot;, col = 2)
par(mfrow = c(1, 1))</code></pre>
<p><img src="figures/05_RNG_transform/unnamed-chunk-3-1.png" width="80%" style="display: block; margin: auto;" /></p>
</div>
</div>
<div id="somas-e-misturas" class="section level1">
<h1><span class="header-section-number">3</span> Somas e misturas</h1>
<p>Somas e misturas de VAs são tipos especiais de transformações. Chamamos de <strong>convolução</strong> a soma de VAs independentes. As <strong>misturas</strong> são VAs formadas pela mistura de outras VAs (discretas ou contínuas).</p>
<div id="convoluções" class="section level2">
<h2><span class="header-section-number">3.1</span> Convoluções</h2>
<p>Seja <span class="math inline">\(X_1, \ldots, X_n\)</span> VAs independentes e identicamente distribuídas, com distribuição comum <span class="math inline">\(X_j \sim X\)</span>, e considere <span class="math inline">\(S = X_1 + \cdots + X_n\)</span>. A função de distribuição da soma <span class="math inline">\(S\)</span> é chamada de <strong>convolução de ordem <span class="math inline">\(n\)</span></strong> de <span class="math inline">\(X\)</span>, e denotada por <span class="math inline">\(F_X^{*(n)}\)</span>.</p>
<p>Portanto, podemos gerar uma convolução diretamente através da geração de <span class="math inline">\(X_1, \ldots, X_n\)</span> e calculando a soma.</p>
<p>Algumas convoluções importantes:</p>
<ol style="list-style-type: decimal">
<li>Se <span class="math inline">\(Z_1, \ldots, Z_n \sim \text{N}(0,1)\)</span>, então <span class="math inline">\(V = \sum_{i=1}^{n} Z_i^2 \sim \chi^2(n)\)</span></li>
<li>Se <span class="math inline">\(U_1, \ldots, U_{12} \sim \text{U}(-1/2,1/2)\)</span>, então <span class="math inline">\(Z = \sum_{i=1}^{12} U_i\)</span> terá distribuição <span class="math inline">\(\text{N}(0,1)\)</span> (usando o <strong>Teorema do Limite Central</strong>).</li>
<li>A distribuição binomial negativa <span class="math inline">\(\text{BinNeg}(r,p)\)</span> pode ser definida como:
<ul>
<li>A convolução de <span class="math inline">\(r\)</span> VAs iid <span class="math inline">\(\text{Geom}(p)\)</span> (<strong>convolução</strong>)</li>
<li>Se <span class="math inline">\(X|\lambda \sim \text{Poisson}(\lambda)\)</span> e <span class="math inline">\(\lambda \sim \text{Gama}(r, \beta)\)</span>, então <span class="math inline">\(X\)</span> terá distribuição binomial negativa com parâmetros <span class="math inline">\(r\)</span> e <span class="math inline">\(p = \beta/(1+\beta)\)</span> (<strong>mistura</strong>)</li>
</ul></li>
<li>A convolução de <span class="math inline">\(r\)</span> VAs independentes <span class="math inline">\(\text{Exp}(\lambda)\)</span> tem distribuição <span class="math inline">\(\text{Gama}(r, \lambda)\)</span>.</li>
<li>A soma de <span class="math inline">\(n\)</span> VAs iid <span class="math inline">\(\text{Ber}(p)\)</span> tem distribuição <span class="math inline">\(\text{Bin}(n,p)\)</span>.</li>
</ol>
<div id="exemplo-distribuição-qui-quadrado" class="section level3">
<h3><span class="header-section-number">3.1.1</span> Exemplo (distribuição qui-quadrado)</h3>
<p>Se <span class="math inline">\(Z_1, \ldots, Z_n \sim \text{N}(0,1)\)</span>, então <span class="math inline">\(V = \sum_{i=1}^{n} Z_i^2 \sim \chi^2(n)\)</span>.</p>
<p>Para gerar <span class="math inline">\(m\)</span> valores de uma <span class="math inline">\(\chi^2(n)\)</span>:</p>
<ol style="list-style-type: decimal">
<li>Crie uma matriz <span class="math inline">\(m \times n\)</span> com <span class="math inline">\(mn\)</span> VAs <span class="math inline">\(\text{N(0,1)}\)</span></li>
<li>Calcule o quadrado de cada número da matriz em (1)</li>
<li>Calcule a soma das linhas da matriz. Cada soma de linha é uma realização da distribuição <span class="math inline">\(\chi^2(n)\)</span></li>
<li>Retorne o vetor com as somas</li>
</ol>
<p>Para gerar <span class="math inline">\(m=1000\)</span> valores da <span class="math inline">\(\chi^2(2)\)</span>:</p>
<pre class="r"><code>m &lt;- 1000
n &lt;- 2
X &lt;- matrix(rnorm(n * m), nrow = m, ncol = n)^2
x &lt;- rowSums(X)
## Comparação
par(mfrow = c(1, 2))
plot(ecdf(x))
curve(pchisq(x, n), add = TRUE, col = 2)
q &lt;- qchisq(ppoints(m), 2)
qqplot(q, x)
abline(0, 1, col = 2)
par(mfrow = c(1, 1))</code></pre>
<p><img src="figures/05_RNG_transform/unnamed-chunk-4-1.png" width="80%" style="display: block; margin: auto;" /></p>
</div>
<div id="exemplo-distribuição-binomial" class="section level3">
<h3><span class="header-section-number">3.1.2</span> Exemplo (distribuição binomial)</h3>
<p>Se <span class="math inline">\(X_1, \ldots, X_n \sim \text{Ber}(p)\)</span>, então <span class="math inline">\(Y = \sum_{i=1}^{n} X_1 + \cdots + X_n\)</span> terá distribuição <span class="math inline">\(\text{Bin}(n,p)\)</span></p>
<p>Para gerar <span class="math inline">\(m\)</span> valores de uma <span class="math inline">\(\text{Bin}(n, p)\)</span> (usando a geração de Bernoulli pela uniforme):</p>
<ol style="list-style-type: decimal">
<li>Crie uma matriz <span class="math inline">\(m \times n\)</span> com <span class="math inline">\(mn\)</span> VAs <span class="math inline">\(\text{U}(0,1)\)</span>
<ul>
<li>Se <span class="math inline">\(u &gt; p\)</span> faça 1, caso contrário 0. Até aqui é o mesmo que gerar <span class="math inline">\(n\)</span> valores aleatórios de uma <span class="math inline">\(\text{Ber}(p)\)</span> em cada linha da matriz</li>
</ul></li>
<li>Calcule a soma das linhas da matriz. Cada soma de linha é uma realização da distribuição <span class="math inline">\(\text{Bin}(n, p)\)</span></li>
<li>Retorne o vetor com as somas</li>
</ol>
<p>Para gerar <span class="math inline">\(m = 1000\)</span> valores de <span class="math inline">\(\text{Bin}(6, 0.5)\)</span>:</p>
<pre class="r"><code>m &lt;- 1000
size &lt;- 6
prob &lt;- 0.5
X &lt;- matrix(runif(m * size) &gt; prob, nrow = m, ncol = size)
x &lt;- rowSums(X)
## Calcula as probabilidades teóricas (exatas) usando a definição da
## distribuição
k &lt;- 0:max(x)
p &lt;- dbinom(k, size = size, prob = prob)
## Compara a proporção de valores gerados com a prob. teórica
round(cbind(&quot;Gerado&quot; = prop.table(table(x)), &quot;Teórico&quot; = p), 3)</code></pre>
<pre><code>#   Gerado Teórico
# 0  0.009   0.016
# 1  0.100   0.094
# 2  0.211   0.234
# 3  0.330   0.312
# 4  0.243   0.234
# 5  0.096   0.094
# 6  0.011   0.016</code></pre>
<pre class="r"><code>## Comparação gráfica
par(mfrow = c(1, 2))
plot(prop.table(table(x)), xlab = &quot;X&quot;, ylab = &quot;P[X]&quot;)
points(p ~ I(k + 0.1), type = &quot;h&quot;, col = 2, lwd = 2)
legend(&quot;topright&quot;, legend = c(&quot;Empírico&quot;, &quot;Teórico&quot;),
       lty = 1, col = c(1, 2))
plot(ecdf(x))
lines(cumsum(p), type = &quot;S&quot;, col = 2)
par(mfrow = c(1, 1))</code></pre>
<p><img src="figures/05_RNG_transform/unnamed-chunk-5-1.png" width="80%" style="display: block; margin: auto;" /></p>
</div>
</div>
</div>
<div id="distribuição-normal" class="section level1">
<h1><span class="header-section-number">4</span> Distribuição normal</h1>
<p>Existem vários métodos para se gerar valores aleatórios de uma distribuição normal.</p>
<p>Geralmente, estes métodos são desenvolvidos para gerar valores de uma distribuição normal padrão <span class="math inline">\(\text{N}(0,1)\)</span>. No entanto, sabemos que a transformação <span class="math display">\[
Z = \frac{X - \mu}{\sigma} \sim \text{N}(0,1)
\]</span> Portanto, podemos obter <span class="math display">\[
X = Z\sigma + \mu
\]</span> que terá distribuição <span class="math inline">\(\text{N}(\mu, \sigma^2)\)</span>, a partir de valores gerados de <span class="math inline">\(Z\)</span>.</p>
<div id="por-convolução" class="section level2">
<h2><span class="header-section-number">4.1</span> Por convolução</h2>
<p>Se <span class="math inline">\(U_1, \ldots, U_{12} \sim \text{U}(-1/2,1/2)\)</span>, então <span class="math inline">\(Z = \sum_{i=1}^{12} U_i\)</span> terá distribuição <span class="math inline">\(\text{N}(0,1)\)</span>.</p>
<p>Note que, neste caso, <span class="math inline">\(\text{E}[Z] = 0\)</span> e <span class="math inline">\(\text{Var}[Z] = 1\)</span>. Pelo <strong>Teorema do Limite Central</strong> (TLC), e sabendo do fato que a Uniforme é simétrica, então <span class="math inline">\(Z \sim \text{N}(0,1)\)</span>.</p>
<p>Para gerar <span class="math inline">\(m\)</span> valores de uma <span class="math inline">\(\text{N}(0, 1)\)</span>:</p>
<ol style="list-style-type: decimal">
<li>Crie uma matriz <span class="math inline">\(m \times n=12\)</span> com <span class="math inline">\(mn\)</span> VAs <span class="math inline">\(\text{U}(-0.5,0.5)\)</span></li>
<li>Calcule a soma das linhas da matriz</li>
<li>Retorne o vetor com as somas</li>
</ol>
<p>Para gerar <span class="math inline">\(m = 1000\)</span> valores de <span class="math inline">\(\text{N}(0, 1)\)</span>:</p>
<pre class="r"><code>m &lt;- 1000
n &lt;- 12
X &lt;- matrix(runif(m * n, -0.5, 0.5), nrow = m, ncol = n)
x &lt;- rowSums(X)
## Comparação
par(mfrow = c(1, 2))
plot(ecdf(x))
curve(pnorm(x), add = TRUE, col = 2)
q &lt;- qnorm(ppoints(m))
qqplot(q, x)
abline(0, 1, col = 2)
par(mfrow = c(1, 1))</code></pre>
<p><img src="figures/05_RNG_transform/unnamed-chunk-6-1.png" width="80%" style="display: block; margin: auto;" /></p>
<p>Note que as caudas da distribuição empírica começa a se afastar um pouco da teórica. De fato, esse é um problema desse método simples por convolução.</p>
<p>Os métodos a seguir são mais recomendados (e utilizados) para gerar valores da normal.</p>
</div>
<div id="método-de-box-muller" class="section level2">
<h2><span class="header-section-number">4.2</span> Método de Box-Muller</h2>
<p>A ideia geral do métopdo desenvolvido por Box e Muller é transformar a relação entre duas normais padrão, de coordenadas cartesianas para coordenadas polares, ou seja,</p>
<pre class="r"><code>plot(rnorm(10000), rnorm(10000))</code></pre>
<p><img src="figures/05_RNG_transform/unnamed-chunk-7-1.png" width="80%" style="display: block; margin: auto;" /> Usando as coordenadas polares, soteiam-se valores do raio (<span class="math inline">\(r\)</span>) e do ângulo <span class="math inline">\(\theta\)</span> (usando associações com a <span class="math inline">\(\text{U}(0,1)\)</span>), que darão as coordenadas <span class="math inline">\((r, \theta)\)</span> em coordenadas polares. Depois, converte-se novamente para o plano cartesiano, obtendo assim um ponto na coordenada <span class="math inline">\((x, y)\)</span>, que representam um par de observações de duas VAs <span class="math inline">\(X, Y \sim \text{N}(0,1)\)</span> independentes.</p>
<p>Assista ao vídeo <a href="https://www.youtube.com/watch?v=lHB7P8-ctLE">A integral Gaussiana</a> no perfil do Luiz Chamon para compreender a passagem de coordenadas cartesianas para coordenadas polares.</p>
<div style="position:relative;height:0;padding-bottom:56.25%">
<p><iframe src="https://www.youtube.com/embed/lHB7P8-ctLE?ecver=2"
          width="640"
          height="360"
          frameborder="0"
          style="position:absolute;width:100%;height:100%;left:0;padding:1em"
          allowfullscreen> </iframe></p>
</div>
<p>Para gerar números aleatórios da distribuição normal padrão, precisamos de valores para o <strong>raio</strong> <span class="math inline">\(r\)</span> e o <strong>ângulo</strong> <span class="math inline">\(\theta\)</span> (em coordenadas polares)de tal forma a poder convertê-los em valores <span class="math inline">\(x\)</span> e <span class="math inline">\(y\)</span> usando as expressões <span class="math display">\[
\begin{cases}
x = r \cos(\theta) \\
y = r \sin(\theta).
\end{cases}
\]</span></p>
<div class="panel panel-primary">
<div class="panel-heading">
Relações trigonométricas
</div>
<div class="panel-body">
<p><img src="img/PolarCoordinates.png" width="60%" style="display: block; margin: auto;" /></p>
</div>
</div>
<p>Dessa forma, o par <span class="math inline">\((x,y)\)</span> será uma realização das variáveis aleatórias <span class="math inline">\((X,Y)\)</span>, que possuem, cada uma, distribuição <span class="math inline">\(\text{N}(0,1)\)</span>.</p>
<p>Valores para o <strong>ângulo</strong> podem ser obtidos pelo produto de uma <span class="math inline">\(\text{Uniforme}(0, 1)\)</span> por <span class="math inline">\(2\pi\)</span>, ou seja <span class="math inline">\(\theta \sim 2\pi U(0, 1)\)</span>.</p>
<p>Para o <strong>raio</strong>, precisamos verificar <strong>qual a distribuição adequada</strong>. Note que a função de distribuição acumulada da variável <span class="math inline">\(R\)</span> pode ser determinada a partir da integral <span class="math display">\[
\begin{align*}
\Pr(R \leq r) &amp;=
\int_{0}^{2\pi} \int_{0}^{r}
  (2\pi)^{-1} s\exp\{-s^2/2\}\, \text{d}s \text{d}\theta \\
&amp;= (2\pi)^{-1} \int_{0}^{2\pi} \text{d}\theta \int_{0}^{r}
  s\exp\{-s^2/2\}\, \text{d}s \\
 &amp;= (2\pi)^{-1} (2\pi) \int_{0}^{r}
  s\exp\{-s^2/2\}\, \text{d}s\\
 &amp;= \int_{0}^{r}
  s\exp\{-s^2/2\}\, \text{d}s.
\end{align*}
\]</span></p>
<p>Para resolver a integral, considere <span class="math inline">\(u = s^2\)</span> e com isso <span class="math inline">\(\text{d}s = \text{d}u/2s\)</span>. Os limites de integração são alterados: quando <span class="math inline">\(s = 0\)</span> tem-se que <span class="math inline">\(u = s^2 = 0\)</span>; quando <span class="math inline">\(s = r\)</span> tem-se que <span class="math inline">\(u = s^2 = r^2\)</span>. Dessa forma, a integral fica <span class="math display">\[
\begin{align*}
\Pr(R \leq r)
 &amp;= \int_{0}^{r}
  s\exp\{-s^2/2\}\, \text{d}s\\
 &amp;= \int_{0}^{r^2}
  s\exp\{-u/2\}\, (2s)^{-1}\text{d}u\\
 &amp;= \frac{1}{2} \int_{0}^{r^2}
  \exp\{-u/2\}\, \text{d}u\\
 &amp;= \frac{1}{2} (-2) (\exp\{-u/2\}) \biggr\rvert_{0}^{r^2}\\
 &amp;= -(\exp\{-u/2\}) \biggr\rvert_{0}^{r^2}\\
 &amp;= -(\exp\{-r^2/2\} - \exp\{-0^2/2\})\\
 &amp;= 1 - \exp\{-r^2/2\}.
\end{align*}
\]</span></p>
<p>O resultado obtido foi a função de distribuição acumulada da variável aleatória <span class="math inline">\(R\)</span>, ou seja, <span class="math inline">\(F(r)\)</span>. Se formos capazes de inverter essa função, poderemos gerar números aleatórios de <span class="math inline">\(R\)</span> usando números uniformes.</p>
<p>A inversa da função <span class="math inline">\(F(r) = 1 - \exp\{-r^2/2\}\)</span> é <span class="math display">\[
\begin{align*}
u &amp;= 1 - \exp\{-r^2/2\}\\
\log(1 - u) &amp;= -r^2/2\\
r &amp;= \pm \sqrt{-2 \log(1 - u)}
\end{align*}
\]</span></p>
<p>Como os valores de <span class="math inline">\(u\)</span> são realizações de uma uniforme padrão, podemos simplificar esse resultado para <span class="math display">\[
  r = \sqrt{-2 \log(u)}
\]</span></p>
<p>Assim, para gerar números da normal padrão, usamos <span class="math display">\[
\begin{cases}
x = \sqrt{-2 \log(u_1)}\, \cos(2\pi u_2)\\
y = \sqrt{-2 \log(u_1)}\, \sin(2\pi u_2),
\end{cases}
\]</span> em que <span class="math inline">\(u_1\)</span> e <span class="math inline">\(u_2\)</span> são números da Uniforme padrão.</p>
<!--
<div class="panel panel-primary">
<div class="panel-heading">Definição alternativa</div>
<div class="panel-body">

http://keyonvafa.com/box-muller-transform/

A ideia por trás do algoritmo de Box-Muller é imaginar duas amostras
independentes $X,Y \sim \text{N}(0,1)$ plotadas no plano cartesiano e
representar esses pontos em coordenadas polares. Para transformar um
poto $(x,y)$ no plano cartesiano para cooordenadas polares, precisamos
da distância do ponto à origem (o raio $r$) e o ângulo $\theta$ que o
raio faz com o eixo $y$.

Começando com o raio, sabemos que $R^2 = X^2 + Y^2$ (por Pitágoras).
Como $X$ e $Y$ são normais padrão, sabemos que o a soma de duas normais
padrão ao quadrado terá uma distribuição $\chi^2$ com dois graus de
liberdade. Também sabemos (por relação entre VAs), que uma distribuição
$\chi^2$ com dois graus de liberdade é equivalente à uma VA
$\text{Gama}(1, 2)$, que, por sua vez, é equivalente à uma VA
$\text{Exp}(2)$. Já vimos também (veja item 8 no começo desta página)
que se $U_1 \sim \text{U}(0,1)$, então $X = - 2 \log U_1$. Resumindo:
$$
R^2 \sim \chi^2(2) \sim \text{Gama}(1, 2) \sim \text{Exp}(2) \sim -2
\log U_1
$$
onde $U_1 \sim \text{U}(0,1)$.
</div>
</div>
-->
<p>O algoritmo de Box-Muller é definido como:</p>
<ol style="list-style-type: decimal">
<li>Gera valores <span class="math inline">\(u_1\)</span> e <span class="math inline">\(u_2\)</span> de <span class="math inline">\(\text{U}(0,1)\)</span></li>
<li>Calcule <span class="math display">\[
\begin{cases}
x_1 = \sqrt{-2 \log(u_1)}\, \cos(2\pi u_2)\\
x_2 = \sqrt{-2 \log(u_1)}\, \sin(2\pi u_2),
\end{cases}
\]</span></li>
<li>Retorne <span class="math inline">\(\{x_1, x_2\}\)</span></li>
</ol>
<pre class="r"><code>## Gerando valores da normal pelo algoritmo de Box-Muller
Nsim &lt;- 2500
## Amostra das uniformes
u1 &lt;- runif(Nsim)
u2 &lt;- runif(Nsim)
## Raio
R &lt;- sqrt(-2 * log(u1))
## Angulo
T &lt;- 2 * pi * u2
x1 &lt;- R * cos(T)
x2 &lt;- R * sin(T)
plot(x1, x2, xlim = c(-4, 4), ylim = c(-4, 4))</code></pre>
<p><img src="figures/05_RNG_transform/unnamed-chunk-10-1.png" width="80%" style="display: block; margin: auto;" /></p>
<pre class="r"><code>## Confere
par(mfrow = c(1, 2))
plot(ecdf(c(x1, x2)))
curve(pnorm(x), add = TRUE, col = 2)
q &lt;- qnorm(ppoints(Nsim))
qqplot(q, c(x1, x2))
abline(0, 1, col = 2)
par(mfrow = c(1, 1))</code></pre>
<p><img src="figures/05_RNG_transform/unnamed-chunk-11-1.png" width="80%" style="display: block; margin: auto;" /></p>
<p>Note que sempre serão geradas duas normais padrão, <code>x1</code> e <code>x2</code>. Com isso, o resultado final será sempre o dobro do valor requerido. Assim, para gerar <span class="math inline">\(n\)</span> valores (e não <span class="math inline">\(2n\)</span>), temos duas opções:</p>
<ol style="list-style-type: decimal">
<li>Usar apenas <code>x1</code> ou <code>x2</code></li>
<li>Rodar o algoritmo em <span class="math inline">\(n/2\)</span> passos e concatenar <code>x1</code> e <code>x2</code></li>
</ol>
<pre class="r"><code>## Uma função mais eficiente
boxmuller &lt;- function(n) {
    ## Executa o algoritmo em somente metade dos valores requeridos
    m &lt;- ceiling(n/2)
    u1 &lt;- runif(m)
    u2 &lt;- runif(m)
    R &lt;- sqrt(-2 * log(u1))
    T &lt;- 2 * pi * u2
    x &lt;- c(R * cos(T), R * sin(T))
    ## Se n for par, retorne tudo, caso contrário, tire um valor
    if (n %% 2 == 0) x else x[-1]
}
boxmuller(2)</code></pre>
<pre><code># [1] 0.9234418 1.0826671</code></pre>
<pre class="r"><code>boxmuller(3)</code></pre>
<pre><code># [1]  0.66055651  0.07799255 -1.80340422</code></pre>
<pre class="r"><code>boxmuller(4)</code></pre>
<pre><code># [1]  0.6975372 -0.3609859 -0.1677477 -0.4755585</code></pre>
<pre class="r"><code>boxmuller(5)</code></pre>
<pre><code># [1] 1.0071460 1.0662797 0.1684460 0.1523806 0.3098626</code></pre>
</div>
<div id="método-de-coordenadas-polares" class="section level2">
<h2><span class="header-section-number">4.3</span> Método de coordenadas polares</h2>
<p>O método de coordenadas polares (ou simplemente método polar) é uma variação do método de Box-Muller. A motivação do método foi a de evitar o uso de funções transcendentais como seno e cossseno.</p>
<ol style="list-style-type: decimal">
<li>Gere valores <span class="math inline">\(u_1, u_2 \sim \text{U}(-1, 1)\)</span></li>
<li>Calcule <span class="math inline">\(r^2 = u_1^2 + u_2^2\)</span>.</li>
<li>Se esse ponto estiver dentro do raio unitário, ou seja, se <span class="math inline">\(r^2 \leq 1\)</span>, então calcule <span class="math inline">\(z = \sqrt{(-2 \log r^2)/r^2}\)</span>
<ul>
<li>Faça <span class="math inline">\(x_1 = u_1 z\)</span> e <span class="math inline">\(x_2 = u_2 z\)</span></li>
</ul></li>
</ol>
<p>Note que apenas substituimos <span class="math inline">\(\cos(2\pi u_2) = u_1/\sqrt{r^2}\)</span> e <span class="math inline">\(\sin(2\pi u_2) = u_2/\sqrt{r^2}\)</span>.</p>
<p>Veja que esse método nada mais é do que uma forma do algoritmo de <strong>aceitação-rejeição</strong>.</p>
<pre class="r"><code>Nsim &lt;- 2500
u1 &lt;- runif(Nsim, -1, 1)
u2 &lt;- runif(Nsim, -1, 1)
r2 &lt;- u1^2 + u2^2
ac &lt;- r2 &lt;= 1
z &lt;- sqrt((-2 * log(r2[ac]))/r2[ac])
x1 &lt;- u1[ac] * z
x2 &lt;- u2[ac] * z
## O código desta função está no final da página
plotcirc()
points(u1[ac], u2[ac], pch = 1, col = 3)
points(u1[!ac], u2[!ac], pch = 1, col = 2)</code></pre>
<p><img src="figures/05_RNG_transform/unnamed-chunk-13-1.png" width="80%" style="display: block; margin: auto;" /></p>
<p>Note que a taxa de aceitação será sempre a razão entre a área do círculo e a área do quadrado. A área do cículo é <span class="math inline">\(A_c = \pi r^2 = \pi\)</span>. A área do quadrado é <span class="math inline">\(A_q = l^2 = (2r)^2 = 4\)</span>. Portanto, a taxa de aceitação (teórica) será <span class="math display">\[
\frac{A_c}{A_q} = \frac{\pi}{4} \approx 0.785
\]</span></p>
<p>A taxa de aceitação da simulação foi</p>
<pre class="r"><code>sum(ac)/Nsim</code></pre>
<pre><code># [1] 0.7912</code></pre>
<div class="panel panel-primary">
<div class="panel-heading">
Aproximando o valor de <span class="math inline">\(\pi\)</span>
</div>
<div class="panel-body">
<p>Note que na relação <span class="math display">\[
\frac{A_c}{A_q} = \frac{\pi}{4}
\]</span> podemos isolar <span class="math inline">\(\pi\)</span> <span class="math display">\[
\pi = \frac{4A_c}{A_q} \approx \frac{4 \text{ #circulo}}{\text{ #quadrado}}
\]</span> para obter uma estimativa do valor de <span class="math inline">\(\pi\)</span></p>
<pre class="r"><code>(4 * sum(ac))/Nsim</code></pre>
<pre><code># [1] 3.1648</code></pre>
</div>
</div>
<p>Conferindo os valores gerados:</p>
<pre class="r"><code>par(mfrow = c(1, 2))
plot(ecdf(c(x1, x2)))
curve(pnorm(x), add = TRUE, col = 2)
q &lt;- qnorm(ppoints(Nsim))
qqplot(q, c(x1, x2))
abline(0, 1, col = 2)
par(mfrow = c(1, 1))</code></pre>
<p><img src="figures/05_RNG_transform/unnamed-chunk-16-1.png" width="80%" style="display: block; margin: auto;" /></p>
<p>Podemos também defnir uma função gernérica para gerar <span class="math inline">\(n\)</span> valores:</p>
<pre class="r"><code>polarmethod &lt;- function(n) {
    m &lt;- ceiling(n/2)
    x1 &lt;- numeric(m)
    x2 &lt;- numeric(m)
    i &lt;- 1
    while (i &lt;= m) {
        u1 &lt;- runif(1, -1, 1)
        u2 &lt;- runif(1, -1, 1)
        R2 &lt;- u1^2 + u2^2
        if (R2 &lt;= 1) {
            z &lt;- sqrt((-2 * log(R2))/R2)
            x1[i] &lt;- u1 * z
            x2[i] &lt;- u2 * z
            i &lt;- i + 1
        }
    }
    x &lt;- c(x1, x2)
    if (n %% 2 == 0) x else x[-1]
}
polarmethod(2)</code></pre>
<pre><code># [1]  0.8877987 -0.9400620</code></pre>
<pre class="r"><code>polarmethod(3)</code></pre>
<pre><code># [1] -0.5380968 -0.2598577 -0.9556475</code></pre>
<pre class="r"><code>polarmethod(4)</code></pre>
<pre><code># [1] 0.1673346 0.9279059 1.1766460 1.7330495</code></pre>
<pre class="r"><code>polarmethod(5)</code></pre>
<pre><code># [1] -1.0159191 -1.4593440  1.1055767 -0.9991863 -1.2083035</code></pre>
<p>Comparando os dois métodos vemos que, apesar do método polar não usar funções seno e cosseno, é necessário usar o <code>while()</code>, o que “encarece” o algoritmo computacionalemnte.</p>
<pre class="r"><code>microbenchmark::microbenchmark(boxmuller(1000), polarmethod(1000))</code></pre>
<pre><code># Unit: microseconds
#               expr    min      lq     mean  median      uq    max neval cld
#    boxmuller(1000)   64.0   66.20   68.264   68.10   69.70   80.8   100  a 
#  polarmethod(1000) 2509.1 2618.05 2858.722 2661.55 2701.55 7219.4   100   b</code></pre>
</div>
<div id="a-função-rnorm" class="section level2">
<h2><span class="header-section-number">4.4</span> A função <code>rnorm()</code></h2>
<p>No R, sabemos que a função <code>rnorm()</code> serve para gerar valores aleatórios da distribuição normal. Esta função usa um algoritmo chamadpo de “inversão”, cujos detalhes estão descritos em <code>help(qnorm)</code>.</p>
<p>No entanto, assim como no caso da Uniforme, também estão implementados outros algoritmos para gerar valores da Normal, incluindo o algoritmo de Box-Muller.</p>
<pre class="r"><code>## Confere os métodos padrão para a geração de valores aleatórios. O
## primeiro algoritmo é da Uniforme, o segundo é o da Normal e o
## terceiro é o método utilizado pela função sample(). Veja os detalhes
## em help(Random)
RNGkind()</code></pre>
<pre><code># [1] &quot;Mersenne-Twister&quot; &quot;Inversion&quot;        &quot;Rejection&quot;</code></pre>
<pre class="r"><code>## Define semente e altera o gerados para o de Box-Muller
set.seed(1, normal.kind = &quot;Box-Muller&quot;)
## Box-MUller pela rnorm
xx &lt;- rnorm(1000)
## Box-Muller implementado aqui
yy &lt;- boxmuller(1000)
RNGkind()</code></pre>
<pre><code># [1] &quot;Mersenne-Twister&quot; &quot;Box-Muller&quot;       &quot;Rejection&quot;</code></pre>
<pre class="r"><code>## Volta para o padrão da rnorm
set.seed(1, normal.kind = &quot;Inversion&quot;)
RNGkind()</code></pre>
<pre><code># [1] &quot;Mersenne-Twister&quot; &quot;Inversion&quot;        &quot;Rejection&quot;</code></pre>
<pre class="r"><code>## Gera valores com o algoritmo padrão
zz &lt;- rnorm(1000)</code></pre>
<p>Comparando todo mundo:</p>
<pre class="r"><code>plot(ecdf(xx), main = &quot;&quot;)
plot(ecdf(yy), col = 3, add = TRUE)
plot(ecdf(zz), col = 4, add = TRUE)
curve(pnorm(x), add = TRUE, col = 2)
legend(&quot;right&quot;,
       legend = c(&quot;Box-Muller (R)&quot;, &quot;Box-Muller (Implementado)&quot;,
                  &quot;Inversion&quot;, &quot;Teórica&quot;), cex = 0.8,
       col = c(1, 3, 4, 2), lty = 1, bty = &quot;n&quot;)</code></pre>
<p><img src="figures/05_RNG_transform/unnamed-chunk-20-1.png" width="80%" style="display: block; margin: auto;" /></p>
</div>
</div>
<div id="funções" class="section level1">
<h1><span class="header-section-number">5</span> Funções</h1>
<pre class="r"><code>plotcirc &lt;- function(xlim = c(-1, 1), ylim = c(-1, 1)) {
    ## eixo x = a + cos \theta * raio
    circx &lt;- cos(seq(0, 2*pi, .01)) * 1
    ## eixo y = b + sin \theta * raio
    circy &lt;- sin(seq(0, 2*pi, .01)) * 1
    ## (a,b) eh o ponto de origem, aqui (0,0)
    plot(circx, circy, type = &quot;l&quot;, xlim = xlim, ylim = ylim,
         xaxs = &quot;i&quot;, yaxs = &quot;i&quot;, asp = 1, xlab = &quot;X&quot;, ylab = &quot;Y&quot;)
    abline(v = c(-1,1), col = 2)
    abline(v = c(0,0), col = 1)
    segments(-1, -1, 1, -1, col = 2)
    segments(-1, 1, 1, 1, col = 2)
    segments(-1, 0, 1, 0, col = 1)
    points(0, 0, pch = 19, col = 1)
}</code></pre>
</div>
<div id="exercícios" class="section level1">
<h1><span class="header-section-number">6</span> Exercícios</h1>
<ol style="list-style-type: decimal">
<li>Faça a implementação das distribuições mencionadas e que não foram implementadas aqui.</li>
</ol>
</div>

<center>
  <hr width="100%" size="3px">
  <p> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.pt_BR">
      <img src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png" alt="Licença Creative Commons 4.0"> </a>
  </p>
  <p> <font size="2"> Este conteúdo
      está disponível por meio da Licença Creative Commons 4.0 </font>
  </p>
</center>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = false;
    options.smoothScroll = false;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
