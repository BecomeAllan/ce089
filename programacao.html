<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Fernando P. Mayer" />


<title>Programando com dados</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-66454501-13"></script>
<script>
 window.dataLayer = window.dataLayer || [];
 function gtag(){dataLayer.push(arguments);}
 gtag('js', new Date());

 gtag('config', 'UA-66454501-13');
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>





<link rel="stylesheet" href="default" type="text/css" />
<link rel="stylesheet" href="config/sydney-site.css" type="text/css" />
<link rel="stylesheet" href="config/sydney-site-fonts.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}

.tocify-subheader {
  display: inline;
}
.tocify-subheader .tocify-item {
  font-size: 0.95em;
}

</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">CE089</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="aulas.html">Aulas</a>
</li>
<li>
  <a href="referencias.html">Referências</a>
</li>
<li>
  <a href="materiais.html">Materiais</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/leg-ufpr/ce089">
    <span class="fab fa-github"></span>
     
    GitHub
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Programando com dados</h1>
<h4 class="author">Fernando P. Mayer</h4>

</div>


<div id="introdução" class="section level1">
<h1><span class="header-section-number">1</span> Introdução</h1>
<p>Por quê programar?</p>
<ul>
<li>Evitar repetições desnecessárias de análises ou cálculos que são repetidos com frequência.</li>
<li>Fica documentado as etapas que você realizou para chegar a um resultado.</li>
<li>Fácil recuperação e modificação de programas.</li>
</ul>
<p>Como programar?</p>
<ul>
<li>Criando programas! (Scripts, rotinas, <strong>algoritmos</strong>).</li>
<li>Crie uma sequência lógica de comandos que devem ser executados em ordem.</li>
<li>Utilize as ferramentas básicas da programação: <strong>estruturas de repetição</strong> (<code>for()</code>) e <strong>estruturas de seleção</strong> (<code>if()</code>).</li>
</ul>
</div>
<div id="estrutura-de-repetição-for" class="section level1">
<h1><span class="header-section-number">2</span> Estrutura de repetição <code>for()</code></h1>
<p>Serve para repetir um ou mais comandos diversas vezes. Para ver como funciona, considere o seguinte exemplo:</p>
<pre class="r"><code>for(i in 1:10){
    print(i)
}</code></pre>
<pre><code># [1] 1
# [1] 2
# [1] 3
# [1] 4
# [1] 5
# [1] 6
# [1] 7
# [1] 8
# [1] 9
# [1] 10</code></pre>
<p>O resultado é a chamada do comando <code>print()</code> para cada valor que o índice <code>i</code> recebe (nesse caso <code>i</code> recebe os valores de 1 a 10).</p>
<p>A sintaxe será sempre nesse formato:</p>
<pre class="r"><code>for(&lt;índice&gt; in &lt;valores&gt;){
    &lt;comandos&gt;
}</code></pre>
<p>Veja outro exemplo em como podemos aplicar o índice:</p>
<pre class="r"><code>x &lt;- 100:200
for(j in 1:10){
    print(x[j])
}</code></pre>
<pre><code># [1] 100
# [1] 101
# [1] 102
# [1] 103
# [1] 104
# [1] 105
# [1] 106
# [1] 107
# [1] 108
# [1] 109</code></pre>
<p>Veja que o índice não precisa ser <code>i</code>, na verdade pode ser qualquer letra ou palavra. Nesse caso, veja que utilizamos os valores como índice para selecionar elementos de <code>x</code> naquelas posições específicas.</p>
<p>Um outro exemplo seria se quisessemos imprimir o quadrado de alguns números (não necessariamente em sequência):</p>
<pre class="r"><code>for(i in c(2, 9, 4, 6)){
    print(i^2)
}</code></pre>
<pre><code># [1] 4
# [1] 81
# [1] 16
# [1] 36</code></pre>
<p>Ou mesmo imprimir caracteres a partir de um vetor de caracteres:</p>
<pre class="r"><code>for(veiculos in c(&quot;carro&quot;, &quot;ônibus&quot;, &quot;trem&quot;, &quot;bicicleta&quot;)){
    print(veiculos)
}</code></pre>
<pre><code># [1] &quot;carro&quot;
# [1] &quot;ônibus&quot;
# [1] &quot;trem&quot;
# [1] &quot;bicicleta&quot;</code></pre>
<p><strong>Exemplo</strong>: cálculo de notas de uma disciplina.</p>
<pre class="r"><code>## Importa os dados
url &lt;- &quot;http://leg.ufpr.br/~fernandomayer/data/notas.csv&quot;
notas &lt;- read.table(url, header = TRUE, sep = &quot;;&quot;, dec = &quot;,&quot;)</code></pre>
<pre class="r"><code>## Analisa a estrutura dos dados
str(notas)</code></pre>
<pre><code># &#39;data.frame&#39;: 30 obs. of  4 variables:
#  $ nome  : chr  &quot;Aluno_1&quot; &quot;Aluno_2&quot; &quot;Aluno_3&quot; &quot;Aluno_4&quot; ...
#  $ prova1: int  8 2 9 1 7 10 1 5 5 10 ...
#  $ prova2: int  4 7 2 10 6 0 8 9 6 2 ...
#  $ prova3: int  1 6 4 9 8 3 0 7 1 3 ...</code></pre>
<pre class="r"><code>head(notas)</code></pre>
<pre><code>#      nome prova1 prova2 prova3
# 1 Aluno_1      8      4      1
# 2 Aluno_2      2      7      6
# 3 Aluno_3      9      2      4
# 4 Aluno_4      1     10      9
# 5 Aluno_5      7      6      8
# 6 Aluno_6     10      0      3</code></pre>
<pre class="r"><code>summary(notas)</code></pre>
<pre><code>#      nome               prova1           prova2           prova3   
#  Length:30          Min.   : 0.000   Min.   : 0.000   Min.   :0.0  
#  Class :character   1st Qu.: 2.000   1st Qu.: 3.000   1st Qu.:3.0  
#  Mode  :character   Median : 4.000   Median : 6.000   Median :6.5  
#                     Mean   : 4.433   Mean   : 5.433   Mean   :5.4  
#                     3rd Qu.: 6.750   3rd Qu.: 8.000   3rd Qu.:8.0  
#                     Max.   :10.000   Max.   :10.000   Max.   :9.0</code></pre>
<p>Antes de seguir adiante, veja o resultado de</p>
<pre class="r"><code>## for(i in 1:30){
##     print(notas[i, c(&quot;prova1&quot;, &quot;prova2&quot;, &quot;prova3&quot;)])
## }
notas[1, c(&quot;prova1&quot;, &quot;prova2&quot;, &quot;prova3&quot;)]</code></pre>
<pre><code>#   prova1 prova2 prova3
# 1      8      4      1</code></pre>
<pre class="r"><code>class(notas[1, c(&quot;prova1&quot;, &quot;prova2&quot;, &quot;prova3&quot;)])</code></pre>
<pre><code># [1] &quot;data.frame&quot;</code></pre>
<pre class="r"><code>as.numeric(notas[1, c(&quot;prova1&quot;, &quot;prova2&quot;, &quot;prova3&quot;)])</code></pre>
<pre><code># [1] 8 4 1</code></pre>
<pre class="r"><code>class(as.numeric(notas[1, c(&quot;prova1&quot;, &quot;prova2&quot;, &quot;prova3&quot;)]))</code></pre>
<pre><code># [1] &quot;numeric&quot;</code></pre>
<p>Para calcular as médias das 3 provas, precisamos inicialmente de um vetor para armazenar os resultados. Esse vetor pode ser um novo objeto ou uma nova coluna no dataframe</p>
<pre class="r"><code>## Aqui vamos criar uma nova coluna no dataframe, contendo apenas o
## valor 0
notas$media &lt;- 0 # note que aqui será usada a regra da reciclagem, ou
                 # seja, o valor zero será repetido até completar todas
                 # as linhas do dataframe
## Estrutura de repetição para calcular a média
for(i in 1:30){
    ## Aqui, cada linha i da coluna media sera substituida pelo
    ## respectivo valor da media caculada
    notas$media[i] &lt;- sum(notas[i, c(&quot;prova1&quot;, &quot;prova2&quot;, &quot;prova3&quot;)])/3
}

## Confere os resultados
head(notas)</code></pre>
<pre><code>#      nome prova1 prova2 prova3    media
# 1 Aluno_1      8      4      1 4.333333
# 2 Aluno_2      2      7      6 5.000000
# 3 Aluno_3      9      2      4 5.000000
# 4 Aluno_4      1     10      9 6.666667
# 5 Aluno_5      7      6      8 7.000000
# 6 Aluno_6     10      0      3 4.333333</code></pre>
<p>Agora podemos melhorar o código, tornando-o mais <strong>genérico</strong>. Dessa forma fica mais fácil fazer alterações e procurar erros. Uma forma de melhorar o código acima é generalizando alguns passos.</p>
<pre class="r"><code>## Armazenamos o número de linhas no dataframe
nlinhas &lt;- nrow(notas)
## Identificamos as colunas de interesse no cálculo da média, e
## armazenamos em um objeto separado
provas &lt;- c(&quot;prova1&quot;, &quot;prova2&quot;, &quot;prova3&quot;)
## Sabendo o número de provas, fica mais fácil dividir pelo total no
## cálculo da média
nprovas &lt;- length(provas)
## Cria uma nova coluna apenas para comparar o cálculo com o anterior
notas$media2 &lt;- 0
## A estrutura de repetição fica
for(i in 1:nlinhas){
    notas$media2[i] &lt;- sum(notas[i, provas])/nprovas
}

## Confere
head(notas)</code></pre>
<pre><code>#      nome prova1 prova2 prova3    media   media2
# 1 Aluno_1      8      4      1 4.333333 4.333333
# 2 Aluno_2      2      7      6 5.000000 5.000000
# 3 Aluno_3      9      2      4 5.000000 5.000000
# 4 Aluno_4      1     10      9 6.666667 6.666667
# 5 Aluno_5      7      6      8 7.000000 7.000000
# 6 Aluno_6     10      0      3 4.333333 4.333333</code></pre>
<pre class="r"><code>identical(notas$media, notas$media2)</code></pre>
<pre><code># [1] TRUE</code></pre>
<p>Ainda podemos melhorar (leia-se: <strong>otimizar</strong>) o código, se utilizarmos funções prontas do R. No caso da média isso é possível pois a função <code>mean()</code> já existe. Em seguida veremos como fazer quando o cálculo que estamos utilizando não está implementado em nenhuma função pronta do R.</p>
<pre class="r"><code>## Cria uma nova coluna apenas para comparação
notas$media3 &lt;- 0
## A estrutura de repetição fica
for(i in 1:nlinhas){
    notas$media3[i] &lt;- mean(as.numeric(notas[i, provas]))
}

## Confere
head(notas)</code></pre>
<pre><code>#      nome prova1 prova2 prova3    media   media2   media3
# 1 Aluno_1      8      4      1 4.333333 4.333333 4.333333
# 2 Aluno_2      2      7      6 5.000000 5.000000 5.000000
# 3 Aluno_3      9      2      4 5.000000 5.000000 5.000000
# 4 Aluno_4      1     10      9 6.666667 6.666667 6.666667
# 5 Aluno_5      7      6      8 7.000000 7.000000 7.000000
# 6 Aluno_6     10      0      3 4.333333 4.333333 4.333333</code></pre>
<pre class="r"><code>## A única diferença é que aqui precisamos transformar cada linha em um
## vetor de números com as.numeric(), pois
notas[1, provas]</code></pre>
<pre><code>#   prova1 prova2 prova3
# 1      8      4      1</code></pre>
<pre class="r"><code>## é um data.frame:
class(notas[1, provas])</code></pre>
<pre><code># [1] &quot;data.frame&quot;</code></pre>
<p>No caso acima vimos que não era necessário calcular a média através de <code>soma/total</code> porque existe uma função pronta no R para fazer esse cálculo. Mas, e se quisessemos, por exemplo, calcular a Coeficiente de Variação (CV) entre as notas das três provas de cada aluno? Uma busca por</p>
<pre class="r"><code>help.search(&quot;coefficient of variation&quot;)</code></pre>
<p>não retorna nenhuma função (dos pacotes básicos) para fazer esse cálculo. O motivo é simples: como é uma conta simples de fazer não há necessidade de se criar uma função extra dentro dos pacotes. No entanto, nós podemos criar uma função que calcule o CV, e usá-la para o nosso propósito</p>
<pre class="r"><code>cv &lt;- function(x){
    desv.pad &lt;- sd(x)
    med &lt;- mean(x)
    cv &lt;- desv.pad/med
    return(cv)
}</code></pre>
<div class="alert alert-warning">
<p>NOTA: na função criada acima o único argumento que usamos foi <code>x</code>, que neste caso deve ser um vetor de números para o cálculo do CV. Os argumentos colocados dentro de <code>function()</code> devem ser apropriados para o propósito de cada função.</p>
</div>
<p>Antes de aplicar a função dentro de um <code>for()</code> devemos testá-la para ver se ela está funcioanando de maneira correta. Por exemplo, o CV para as notas do primeiro aluno pode ser calculado “manualmente” por</p>
<pre class="r"><code>sd(as.numeric(notas[1, provas]))/mean(as.numeric(notas[1, provas]))</code></pre>
<pre><code># [1] 0.8104349</code></pre>
<p>E através da função, o resultado é</p>
<pre class="r"><code>cv(as.numeric(notas[1, provas]))</code></pre>
<pre><code># [1] 0.8104349</code></pre>
<p>o que mostra que a função está funcionando corretamente, e podemos aplicá-la em todas as linhas usando a repetição</p>
<pre class="r"><code>## Cria uma nova coluna para o CV
notas$CV &lt;- 0
## A estrutura de repetição fica
for(i in 1:nlinhas){
    notas$CV[i] &lt;- cv(as.numeric(notas[i, provas]))
}

## Confere
head(notas)</code></pre>
<pre><code>#      nome prova1 prova2 prova3    media   media2   media3        CV
# 1 Aluno_1      8      4      1 4.333333 4.333333 4.333333 0.8104349
# 2 Aluno_2      2      7      6 5.000000 5.000000 5.000000 0.5291503
# 3 Aluno_3      9      2      4 5.000000 5.000000 5.000000 0.7211103
# 4 Aluno_4      1     10      9 6.666667 6.666667 6.666667 0.7399324
# 5 Aluno_5      7      6      8 7.000000 7.000000 7.000000 0.1428571
# 6 Aluno_6     10      0      3 4.333333 4.333333 4.333333 1.1842157</code></pre>
<p>Podemos agora querer calcular as médias ponderadas para as provas. Por exemplo:</p>
<ul>
<li>Prova 1: peso 3</li>
<li>Prova 2: peso 3</li>
<li>Prova 3: peso 4</li>
</ul>
<p>Usando a fórmula:</p>
<p><span class="math display">\[
\bar{x} = \frac{1}{N} \sum_{i=1}^{n} x_i \cdot w_i
\]</span></p>
<p>onde <span class="math inline">\(w_i\)</span> são os pesos, e <span class="math inline">\(N = \sum_{i=1}^{n} w_i\)</span> é a soma dos pesos. Como já vimos que criar uma função é uma forma mais prática (e elegante) de executar determinada tarefa, vamos criar uma função que calcule as médias ponderadas.</p>
<pre class="r"><code>med.pond &lt;- function(notas, pesos){
    ## Multiplica o valor de cada prova pelo seu peso
    pond &lt;- notas * pesos
    ## Calcula o valor total dos pesos
    peso.total &lt;- sum(pesos)
    ## Calcula a soma da ponderação
    sum.pond &lt;- sum(pond)
    ## Finalmente calcula a média ponderada
    saida &lt;- sum.pond/peso.total
    return(saida)
}</code></pre>
<p>Antes de aplicar a função para o caso geral, sempre é importante testar e conferir o resultado em um caso menor. Podemos verificar o resultado da média ponderada para o primeiro aluno</p>
<pre class="r"><code>sum(notas[1, provas] * c(3, 3, 4))/10</code></pre>
<pre><code># [1] 4</code></pre>
<p>e testar a função para o mesmo caso</p>
<pre class="r"><code>med.pond(notas = notas[1, provas], pesos = c(3, 3, 4))</code></pre>
<pre><code># [1] 4</code></pre>
<p>Como o resultado é o mesmo podemos aplicar a função para todas as linhas através do <code>for()</code></p>
<pre class="r"><code>## Cria uma nova coluna para a média ponderada
notas$MP &lt;- 0
## A estrutura de repetição fica
for(i in 1:nlinhas){
    notas$MP[i] &lt;- med.pond(notas = notas[i, provas], pesos = c(3, 3, 4))
}

## Confere
head(notas)</code></pre>
<pre><code>#      nome prova1 prova2 prova3    media   media2   media3        CV  MP
# 1 Aluno_1      8      4      1 4.333333 4.333333 4.333333 0.8104349 4.0
# 2 Aluno_2      2      7      6 5.000000 5.000000 5.000000 0.5291503 5.1
# 3 Aluno_3      9      2      4 5.000000 5.000000 5.000000 0.7211103 4.9
# 4 Aluno_4      1     10      9 6.666667 6.666667 6.666667 0.7399324 6.9
# 5 Aluno_5      7      6      8 7.000000 7.000000 7.000000 0.1428571 7.1
# 6 Aluno_6     10      0      3 4.333333 4.333333 4.333333 1.1842157 4.2</code></pre>
<div class="alert alert-warning">
<p>NOTA: uma função para calcular a média ponderada já existe implementada no R. Veja <code>?weighted.mean()</code> e confira os resultados obtidos aqui</p>
</div>
<p>Repare na construção da função acima: agora usamos dois argumentos, <code>notas</code> e <code>pesos</code>, pois precisamos dos doiss vetores para calcular a média ponderada. Repare também que ambos argumentos não possuem um valor padrão. Poderíamos, por exemplo, assumir valores padrão para os pesos, e deixar para que o usuário mude apenas se achar necessário.</p>
<pre class="r"><code>## Atribuindo pesos iguais para as provas como padrão
med.pond &lt;- function(notas, pesos = rep(1, length(notas))){
    ## Multiplica o valor de cada prova pelo seu peso
    pond &lt;- notas * pesos
    ## Calcula o valor total dos pesos
    peso.total &lt;- sum(pesos)
    ## Calcula a soma da ponderação
    sum.pond &lt;- sum(pond)
    ## Finalmente calcula a média ponderada
    saida &lt;- sum.pond/peso.total
    return(saida)
}</code></pre>
<p>Repare que neste caso, como os pesos são iguais, a chamada da função sem alterar o argumento <code>pesos</code> gera o mesmo resultado do cálculo da média comum.</p>
<pre class="r"><code>## Cria uma nova coluna para a média ponderada para comparação
notas$MP2 &lt;- 0
## A estrutura de repetição fica
for(i in 1:nlinhas){
    notas$MP2[i] &lt;- med.pond(notas = notas[i, provas])
}

## Confere
head(notas)</code></pre>
<pre><code>#      nome prova1 prova2 prova3    media   media2   media3        CV  MP
# 1 Aluno_1      8      4      1 4.333333 4.333333 4.333333 0.8104349 4.0
# 2 Aluno_2      2      7      6 5.000000 5.000000 5.000000 0.5291503 5.1
# 3 Aluno_3      9      2      4 5.000000 5.000000 5.000000 0.7211103 4.9
# 4 Aluno_4      1     10      9 6.666667 6.666667 6.666667 0.7399324 6.9
# 5 Aluno_5      7      6      8 7.000000 7.000000 7.000000 0.1428571 7.1
# 6 Aluno_6     10      0      3 4.333333 4.333333 4.333333 1.1842157 4.2
#        MP2
# 1 4.333333
# 2 5.000000
# 3 5.000000
# 4 6.666667
# 5 7.000000
# 6 4.333333</code></pre>
</div>
<div id="estrutura-de-seleção-if" class="section level1">
<h1><span class="header-section-number">3</span> Estrutura de seleção <code>if()</code></h1>
<p>Uma estrutura de seleção serve para executar algum comando apenas se alguma condição (em forma de <strong>expressão condicional</strong>) seja satisfeita. Geralmente é utilizada dentro de um <code>for()</code>.</p>
<p>No exemplo inicial poderíamos querer imprimir um resultado caso satisfaça determinada condição. Por exemplo, se o valor de <code>x</code> for menor ou igual a 105, então imprima um texto informando isso.</p>
<pre class="r"><code>x &lt;- 100:200
for(j in 1:10){
    if(x[j] &lt;= 105){
        print(&quot;Menor ou igual a 105&quot;)
    }
}</code></pre>
<pre><code># [1] &quot;Menor ou igual a 105&quot;
# [1] &quot;Menor ou igual a 105&quot;
# [1] &quot;Menor ou igual a 105&quot;
# [1] &quot;Menor ou igual a 105&quot;
# [1] &quot;Menor ou igual a 105&quot;
# [1] &quot;Menor ou igual a 105&quot;</code></pre>
<p>Mas também podemos considerar o que aconteceria caso contrário. Por exemplo, se o valor de <code>x</code>for maior do que 105, então imprima outro texto.</p>
<pre class="r"><code>x &lt;- 100:200
for(j in 1:10){
    if(x[j] &lt;= 105){
        print(&quot;Menor ou igual a 105&quot;)
    } else{
        print(&quot;Maior do que 105&quot;)
    }
}</code></pre>
<pre><code># [1] &quot;Menor ou igual a 105&quot;
# [1] &quot;Menor ou igual a 105&quot;
# [1] &quot;Menor ou igual a 105&quot;
# [1] &quot;Menor ou igual a 105&quot;
# [1] &quot;Menor ou igual a 105&quot;
# [1] &quot;Menor ou igual a 105&quot;
# [1] &quot;Maior do que 105&quot;
# [1] &quot;Maior do que 105&quot;
# [1] &quot;Maior do que 105&quot;
# [1] &quot;Maior do que 105&quot;</code></pre>
<p>A sintaxe será sempre no formato:</p>
<pre class="r"><code>if(&lt;condição&gt;){
    &lt;comandos que satisfazem a condição&gt;
} else{
   &lt;comandos que não satisfazem a condição&gt;
}</code></pre>
<p>Como vimos acima, a especificação do <code>else{}</code> não é obrigatória.</p>
<p>Voltando ao exemplo das notas, podemos adicionar uma coluna com a condição do aluno: <code>aprovado</code> ou <code>reprovado</code> de acordo com a sua nota. Para isso precisamos criar uma condição (nesse caso se a nota é maior do que 7), e verificar se ela é verdadeira.</p>
<pre class="r"><code>## Nova coluna para armazenar a situacao
notas$situacao &lt;- NA # aqui usamos NA porque o resultado será um
                     # caracter
## Estrutura de repetição
for(i in 1:nlinhas){
    ## Estrutura de seleção (usando a média ponderada)
    if(notas$MP[i] &gt;= 7){
        notas$situacao[i] &lt;- &quot;aprovado&quot;
    } else{
        notas$situacao[i] &lt;- &quot;reprovado&quot;
    }
}

## Confere
head(notas)</code></pre>
<pre><code>#      nome prova1 prova2 prova3    media   media2   media3        CV  MP
# 1 Aluno_1      8      4      1 4.333333 4.333333 4.333333 0.8104349 4.0
# 2 Aluno_2      2      7      6 5.000000 5.000000 5.000000 0.5291503 5.1
# 3 Aluno_3      9      2      4 5.000000 5.000000 5.000000 0.7211103 4.9
# 4 Aluno_4      1     10      9 6.666667 6.666667 6.666667 0.7399324 6.9
# 5 Aluno_5      7      6      8 7.000000 7.000000 7.000000 0.1428571 7.1
# 6 Aluno_6     10      0      3 4.333333 4.333333 4.333333 1.1842157 4.2
#        MP2  situacao
# 1 4.333333 reprovado
# 2 5.000000 reprovado
# 3 5.000000 reprovado
# 4 6.666667 reprovado
# 5 7.000000  aprovado
# 6 4.333333 reprovado</code></pre>
</div>
<div id="o-modo-do-r-vetorização" class="section level1">
<h1><span class="header-section-number">4</span> O modo do R: vetorização</h1>
<p>As funções vetorizadas do R, além de facilitar e resumir a execução de tarefas repetitivas, também são computacionalmente mais eficientes, <em>i.e.</em> o tempo de execução das rotinas é muito mais rápido.</p>
<p>Já vimos que a <strong>regra da reciclagem</strong> é uma forma de vetorizar cálculos no R. Os cálculos feitos com funções vetorizadas (ou usando a regra de reciclagem) são muito mais eficientes (e preferíveis) no R. Por exemplo, podemos criar um vetor muito grande de números e querer calcular o quadrado de cada número. Se pensássemos em usar uma estrutura de repetição, o cálculo seria o seguinte:</p>
<pre class="r"><code>## Vetor com uma sequência de 1 a 1.000.000
x &lt;- 1:1000000
## Calcula o quadrado de cada número da sequência em x usando for()
y1 &lt;- numeric(length(x)) # vetor de mesmo comprimento de x que vai
                         # receber os resultados
for(i in 1:length(x)){
    y1[i] &lt;- x[i]^2
}</code></pre>
<p>Mas, da forma vetorial e usando a regra da reciclagem, a mesma operação pode ser feita apenas com</p>
<pre class="r"><code>## Calcula o quadrado de cada número da sequência em x usando a regra da
## reciclagem
y2 &lt;- x^2
## Confere os resultados
identical(y1, y2)</code></pre>
<pre><code># [1] TRUE</code></pre>
<p>Note que os resultados são exatamente iguais, mas então porque se prefere o formato vetorial? Primeiro porque é muito mais simples de escrever, e segundo (e principalmente) porque a forma vetorizada é muito mais <strong>eficiente computacionalmente</strong>. A eficiência computacional pode ser medida de várias formas (alocação de memória, tempo de execução, etc), mas apenas para comparação, vamos medir o tempo de execução destas mesmas operações usando o <code>for()</code> e usando a regra da reciclagem.</p>
<pre class="r"><code>## Tempo de execução usando for()
y1 &lt;- numeric(length(x))
st1 &lt;- system.time(
    for(i in 1:length(x)){
        y1[i] &lt;- x[i]^2
    }
)
st1</code></pre>
<pre><code>#    user  system elapsed 
#    0.08    0.00    0.08</code></pre>
<pre class="r"><code>## Tempo de execução usando a regra da reciclagem
st2 &lt;- system.time(
    y2 &lt;- x^2
)
st2</code></pre>
<pre><code>#    user  system elapsed 
#   0.002   0.000   0.003</code></pre>
<p>Olhando o resultado de <code>elapsed</code>, que é o tempo total de execução de uma função medido por <code>system.time()</code>, notamos que usando a regra da reciclagem, o cálculo é aproximadamente 0.08/0.003 = 26.67 vezes mais rápido. Claramente esse é só um exemplo de um cálculo muito simples. Mas em situações mais complexas, a diferença entro o tempo de execução das duas formas pode ser muito maior.</p>
<div class="panel panel-primary">
<div class="panel-heading">
Uma nota de precaução
</div>
<div class="panel-body">
<p>Existem duas formas básicas de tornar um loop <code>for</code> no R mais rápido:</p>
<ol style="list-style-type: decimal">
<li>Faça o máximo possível fora do loop</li>
<li>Crie um objeto com tamanho suficiente para armazenar <em>todos</em> os resultados do loop <strong>antes</strong> de executá-lo</li>
</ol>
<p>Veja este exemplo:</p>
<pre class="r"><code>## Vetor com uma sequência de 1 a 1.000.000
x &lt;- 1:1000000

## Cria um objeto de armazenamento com o mesmo tamanho do resultado
st1 &lt;- system.time({
    out1 &lt;- numeric(length(x))
    for(i in 1:length(x)){
        out1[i] &lt;- x[i]^2
    }
})

## Cria um objeto de tamanho &quot;zero&quot; e vai &quot;crescendo&quot; esse vetor
st2 &lt;- system.time({
    out2 &lt;- numeric(0)
    for(i in 1:length(x)){
        out2[i] &lt;- x[i]^2
    }
})

## Cria um objeto de tamanho &quot;zero&quot; e cresce o vetor usando a função c()
## NUNCA faça isso!!
st3 &lt;- system.time({
    out3 &lt;- numeric(0)
    for(i in 1:length(x)){
        out3 &lt;- c(out3, x[i]^2)
    }
})</code></pre>
<p>Veja que os objetos criados são de fato idênticos, mas os tempos de execução são bem diferentes</p>
<pre class="r"><code>identical(out1, out2, out3)</code></pre>
<pre><code># [1] TRUE</code></pre>
<pre class="r"><code>rbind(st1, st2, st3)[,1:3]</code></pre>
<pre><code>#     user.self sys.self  elapsed
# st1     0.071    0.003    0.074
# st2     0.255    0.016    0.272
# st3  1179.823  147.493 1330.463</code></pre>
<p>Essa simples diferença gera um aumento de tempo de execução da segunda forma, em relação à primeira, de aproximadamente 0.272/0.074 = 3.68 vezes. Já utilizando a terceira forma, “crescendo” o vetor com a função <code>c()</code>, o aumento de tempo (em relação ao primeiro) é de aproximadamente 1330.463/0.074 = 17979 vezes! Isso acontece porque o vetor <code>out</code> precisa ter seu tamanho aumentado com um elemento a cada iteração. Para fazer isso, o R precisa encontrar um espaço na memória que possa armazenar o objeto maior. É necessário então copiar o vetor de saída e apagar sua versão anterior antes de seguir para o próximo loop. Ao final, foi necessário escrever um milhão de vezes na memória do computador.</p>
<p>Já no primeiro caso, o tamanho do vetor de armazenamento nunca muda, e a memória para esse vetor já foi alocada previamente, de uma única vez.</p>
<p><img src="img/R_club.jpg" width="90%" style="display: block; margin: auto;" /></p>
</div>
</div>
<p>Voltando ao exemplo das notas, por exemplo, o cálculo da média simples poderia ser feita diretamente com a função <code>apply()</code></p>
<pre class="r"><code>notas$media.apply &lt;- apply(X = notas[, provas], MARGIN = 1, FUN = mean)
head(notas)</code></pre>
<pre><code>#      nome prova1 prova2 prova3    media   media2   media3        CV  MP
# 1 Aluno_1      8      4      1 4.333333 4.333333 4.333333 0.8104349 4.0
# 2 Aluno_2      2      7      6 5.000000 5.000000 5.000000 0.5291503 5.1
# 3 Aluno_3      9      2      4 5.000000 5.000000 5.000000 0.7211103 4.9
# 4 Aluno_4      1     10      9 6.666667 6.666667 6.666667 0.7399324 6.9
# 5 Aluno_5      7      6      8 7.000000 7.000000 7.000000 0.1428571 7.1
# 6 Aluno_6     10      0      3 4.333333 4.333333 4.333333 1.1842157 4.2
#        MP2  situacao media.apply
# 1 4.333333 reprovado    4.333333
# 2 5.000000 reprovado    5.000000
# 3 5.000000 reprovado    5.000000
# 4 6.666667 reprovado    6.666667
# 5 7.000000  aprovado    7.000000
# 6 4.333333 reprovado    4.333333</code></pre>
<p>As médias ponderadas poderiam ser calculadas da mesma forma, e usando a função que criamos anteriormente</p>
<pre class="r"><code>notas$MP.apply &lt;- apply(X = notas[, provas], MARGIN = 1, FUN = med.pond)
head(notas)</code></pre>
<pre><code>#      nome prova1 prova2 prova3    media   media2   media3        CV  MP
# 1 Aluno_1      8      4      1 4.333333 4.333333 4.333333 0.8104349 4.0
# 2 Aluno_2      2      7      6 5.000000 5.000000 5.000000 0.5291503 5.1
# 3 Aluno_3      9      2      4 5.000000 5.000000 5.000000 0.7211103 4.9
# 4 Aluno_4      1     10      9 6.666667 6.666667 6.666667 0.7399324 6.9
# 5 Aluno_5      7      6      8 7.000000 7.000000 7.000000 0.1428571 7.1
# 6 Aluno_6     10      0      3 4.333333 4.333333 4.333333 1.1842157 4.2
#        MP2  situacao media.apply MP.apply
# 1 4.333333 reprovado    4.333333 4.333333
# 2 5.000000 reprovado    5.000000 5.000000
# 3 5.000000 reprovado    5.000000 5.000000
# 4 6.666667 reprovado    6.666667 6.666667
# 5 7.000000  aprovado    7.000000 7.000000
# 6 4.333333 reprovado    4.333333 4.333333</code></pre>
<p>Mas note que como temos o argumento <code>pesos</code> especificado com um padrão, devemos alterar na própria função <code>apply()</code></p>
<pre class="r"><code>notas$MP.apply &lt;- apply(X = notas[, provas], MARGIN = 1,
                        FUN = med.pond, pesos = c(3, 3, 4))
head(notas)</code></pre>
<pre><code>#      nome prova1 prova2 prova3    media   media2   media3        CV  MP
# 1 Aluno_1      8      4      1 4.333333 4.333333 4.333333 0.8104349 4.0
# 2 Aluno_2      2      7      6 5.000000 5.000000 5.000000 0.5291503 5.1
# 3 Aluno_3      9      2      4 5.000000 5.000000 5.000000 0.7211103 4.9
# 4 Aluno_4      1     10      9 6.666667 6.666667 6.666667 0.7399324 6.9
# 5 Aluno_5      7      6      8 7.000000 7.000000 7.000000 0.1428571 7.1
# 6 Aluno_6     10      0      3 4.333333 4.333333 4.333333 1.1842157 4.2
#        MP2  situacao media.apply MP.apply
# 1 4.333333 reprovado    4.333333      4.0
# 2 5.000000 reprovado    5.000000      5.1
# 3 5.000000 reprovado    5.000000      4.9
# 4 6.666667 reprovado    6.666667      6.9
# 5 7.000000  aprovado    7.000000      7.1
# 6 4.333333 reprovado    4.333333      4.2</code></pre>
<div class="alert alert-warning">
<p>NOTA: veja que isso é possível devido à presença do argumento <code>...</code> na função <code>apply()</code>, que permite passar argumentos de outras funções dentro dela.</p>
</div>
<p>Também poderíamos usar a função <code>weighted.mean()</code> implementada no R</p>
<pre class="r"><code>notas$MP2.apply &lt;- apply(X = notas[, provas], MARGIN = 1,
                         FUN = weighted.mean, w = c(3, 3, 4))
head(notas)</code></pre>
<pre><code>#      nome prova1 prova2 prova3    media   media2   media3        CV  MP
# 1 Aluno_1      8      4      1 4.333333 4.333333 4.333333 0.8104349 4.0
# 2 Aluno_2      2      7      6 5.000000 5.000000 5.000000 0.5291503 5.1
# 3 Aluno_3      9      2      4 5.000000 5.000000 5.000000 0.7211103 4.9
# 4 Aluno_4      1     10      9 6.666667 6.666667 6.666667 0.7399324 6.9
# 5 Aluno_5      7      6      8 7.000000 7.000000 7.000000 0.1428571 7.1
# 6 Aluno_6     10      0      3 4.333333 4.333333 4.333333 1.1842157 4.2
#        MP2  situacao media.apply MP.apply MP2.apply
# 1 4.333333 reprovado    4.333333      4.0       4.0
# 2 5.000000 reprovado    5.000000      5.1       5.1
# 3 5.000000 reprovado    5.000000      4.9       4.9
# 4 6.666667 reprovado    6.666667      6.9       6.9
# 5 7.000000  aprovado    7.000000      7.1       7.1
# 6 4.333333 reprovado    4.333333      4.2       4.2</code></pre>
<p>O Coeficiente de Variação poderia ser calculado usando nossa função <code>cv()</code></p>
<pre class="r"><code>notas$CV.apply &lt;- apply(X = notas[, provas], MARGIN = 1, FUN = cv)
head(notas)</code></pre>
<pre><code>#      nome prova1 prova2 prova3    media   media2   media3        CV  MP
# 1 Aluno_1      8      4      1 4.333333 4.333333 4.333333 0.8104349 4.0
# 2 Aluno_2      2      7      6 5.000000 5.000000 5.000000 0.5291503 5.1
# 3 Aluno_3      9      2      4 5.000000 5.000000 5.000000 0.7211103 4.9
# 4 Aluno_4      1     10      9 6.666667 6.666667 6.666667 0.7399324 6.9
# 5 Aluno_5      7      6      8 7.000000 7.000000 7.000000 0.1428571 7.1
# 6 Aluno_6     10      0      3 4.333333 4.333333 4.333333 1.1842157 4.2
#        MP2  situacao media.apply MP.apply MP2.apply  CV.apply
# 1 4.333333 reprovado    4.333333      4.0       4.0 0.8104349
# 2 5.000000 reprovado    5.000000      5.1       5.1 0.5291503
# 3 5.000000 reprovado    5.000000      4.9       4.9 0.7211103
# 4 6.666667 reprovado    6.666667      6.9       6.9 0.7399324
# 5 7.000000  aprovado    7.000000      7.1       7.1 0.1428571
# 6 4.333333 reprovado    4.333333      4.2       4.2 1.1842157</code></pre>
<p>Finalmente, a estrutura de repetição <code>if()</code> também possui uma forma vetorizada através da função <code>ifelse()</code>. Essa função funciona da seguinte forma:</p>
<pre class="r"><code>ifelse(&lt;condição&gt;, &lt;valor se verdadeiro&gt;, &lt;valor se falso&gt;)</code></pre>
<p>Dessa forma, a atribuição da situação dos alunos poderia ser feita da seguinte forma:</p>
<pre class="r"><code>notas$situacao2 &lt;- ifelse(notas$MP &gt;= 7, &quot;aprovado&quot;, &quot;reprovado&quot;)
head(notas)</code></pre>
<pre><code>#      nome prova1 prova2 prova3    media   media2   media3        CV  MP
# 1 Aluno_1      8      4      1 4.333333 4.333333 4.333333 0.8104349 4.0
# 2 Aluno_2      2      7      6 5.000000 5.000000 5.000000 0.5291503 5.1
# 3 Aluno_3      9      2      4 5.000000 5.000000 5.000000 0.7211103 4.9
# 4 Aluno_4      1     10      9 6.666667 6.666667 6.666667 0.7399324 6.9
# 5 Aluno_5      7      6      8 7.000000 7.000000 7.000000 0.1428571 7.1
# 6 Aluno_6     10      0      3 4.333333 4.333333 4.333333 1.1842157 4.2
#        MP2  situacao media.apply MP.apply MP2.apply  CV.apply situacao2
# 1 4.333333 reprovado    4.333333      4.0       4.0 0.8104349 reprovado
# 2 5.000000 reprovado    5.000000      5.1       5.1 0.5291503 reprovado
# 3 5.000000 reprovado    5.000000      4.9       4.9 0.7211103 reprovado
# 4 6.666667 reprovado    6.666667      6.9       6.9 0.7399324 reprovado
# 5 7.000000  aprovado    7.000000      7.1       7.1 0.1428571  aprovado
# 6 4.333333 reprovado    4.333333      4.2       4.2 1.1842157 reprovado</code></pre>
</div>
<div id="a-família-de-funções-apply" class="section level1">
<h1><span class="header-section-number">5</span> A família de funções <code>*apply()</code></h1>
<p>As funções da chamada família <code>*apply()</code> são as implementações básicas de operações vetorizadas no R. Sempre que possível é desejável utilizar estas funções no lugar das estruturas de repetição. Em qualquer situação, a performance destas funções (em tempo computacional) será sempre superior</p>
<p>A função <code>apply()</code>, como já vista acima, é capaz de fazer operações nas linhas (<code>MARGIN = 1</code>) e também nas colunas (<code>MARGIN = 2</code>).</p>
<pre class="r"><code>## Médias por LINHA: média das 3 provas para cada aluno
apply(X = notas[, provas], MARGIN = 1, FUN = mean)</code></pre>
<pre><code>#  [1] 4.333333 5.000000 5.000000 6.666667 7.000000 4.333333 3.000000 7.000000
#  [9] 4.000000 5.000000 2.666667 4.000000 6.000000 5.666667 6.000000 4.333333
# [17] 4.666667 6.333333 5.000000 4.333333 6.333333 4.666667 3.666667 3.333333
# [25] 2.666667 7.000000 5.666667 8.000000 3.666667 7.333333</code></pre>
<pre class="r"><code>## Médias por COLUNA: média de cada uma das 3 provas para todos os
## alunos
apply(X = notas[, provas], MARGIN = 2, FUN = mean)</code></pre>
<pre><code>#   prova1   prova2   prova3 
# 4.433333 5.433333 5.400000</code></pre>
<p>As funções <code>sapply()</code> e <code>lapply()</code> são semelhantes à <code>apply()</code>, mas operam somente nas colunas.</p>
<pre class="r"><code>## sapply simpilifica o resultado para um vetor
sapply(notas[, provas],  mean)</code></pre>
<pre><code>#   prova1   prova2   prova3 
# 4.433333 5.433333 5.400000</code></pre>
<pre class="r"><code>## lapply retorna o resultado em formato de lista
lapply(notas[, provas],  mean)</code></pre>
<pre><code># $prova1
# [1] 4.433333
# 
# $prova2
# [1] 5.433333
# 
# $prova3
# [1] 5.4</code></pre>
<p>A função <code>tapply()</code> é similar às anteriores (opera somente nas colunas), mas permite separar o resultado por alguma outr variável (<code>INDEX</code>).</p>
<pre class="r"><code>## Média da prova 1 por situação
tapply(notas$prova1,  notas$situacao,  mean)</code></pre>
<pre><code>#  aprovado reprovado 
#      5.00      4.32</code></pre>
<pre class="r"><code>## Média da prova 2 por situação
tapply(notas$prova2,  notas$situacao,  mean)</code></pre>
<pre><code>#  aprovado reprovado 
#       8.6       4.8</code></pre>
<pre class="r"><code>## Média da prova 3 por situação
tapply(notas$prova3,  notas$situacao,  mean)</code></pre>
<pre><code>#  aprovado reprovado 
#      8.20      4.84</code></pre>
<p>No entanto, a função <code>tapply()</code> aceita somente uma variável por vez. Se quisermos, por exemplo, obter a média por situação das 3 provas de uma só vez, podemos usar a função <code>aggregate()</code>.</p>
<pre class="r"><code>## Mesmo resultado da tapply, mas agora em formato de data frame
aggregate(prova1 ~ situacao, data = notas, FUN = mean)</code></pre>
<pre><code>#    situacao prova1
# 1  aprovado   5.00
# 2 reprovado   4.32</code></pre>
<pre class="r"><code>aggregate(prova2 ~ situacao, data = notas, FUN = mean)</code></pre>
<pre><code>#    situacao prova2
# 1  aprovado    8.6
# 2 reprovado    4.8</code></pre>
<pre class="r"><code>aggregate(prova3 ~ situacao, data = notas, FUN = mean)</code></pre>
<pre><code>#    situacao prova3
# 1  aprovado   8.20
# 2 reprovado   4.84</code></pre>
<pre class="r"><code>## Mas aqui podemos passar as 3 colunas de uma vez
aggregate(cbind(prova1, prova2, prova3) ~ situacao,
          data = notas, FUN = mean)</code></pre>
<pre><code>#    situacao prova1 prova2 prova3
# 1  aprovado   5.00    8.6   8.20
# 2 reprovado   4.32    4.8   4.84</code></pre>
</div>
<div id="outras-estruturas-while-e-repeat" class="section level1">
<h1><span class="header-section-number">6</span> Outras estruturas: while e repeat</h1>
<p>O <code>while</code> executa comandos enquanto uma determinada condição permanece verdadeira.</p>
<pre class="r"><code>## Calcule a soma em 1,2,3... até que o soma seja maior do que 1000
n &lt;- 0
soma &lt;- 0
while(soma &lt;= 1000){
    n &lt;- n + 1
    soma &lt;- soma + n
}
soma</code></pre>
<pre><code># [1] 1035</code></pre>
<p>O <code>repeat</code> é ainda mais básico, e irá executar comandos até que você explicitamente pare a execução com o comando <code>break</code>.</p>
<pre class="r"><code>## Mesmo exemplo
n &lt;- 0
soma &lt;- 0
repeat{
    n &lt;- n + 1
    soma &lt;- soma + n
    if(soma &gt; 1000) break
}
soma</code></pre>
<pre><code># [1] 1035</code></pre>
</div>

<center>
  <hr width="100%" size="3px">
  <p> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.pt_BR">
      <img src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png" alt="Licença Creative Commons 4.0"> </a>
  </p>
  <p> <font size="2"> Este conteúdo
      está disponível por meio da Licença Creative Commons 4.0 </font>
  </p>
</center>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = false;
    options.smoothScroll = false;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
