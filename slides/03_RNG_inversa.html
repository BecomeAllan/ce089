<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Geração de números aleatórios não uniformes</title>
    <meta charset="utf-8" />
    <meta name="author" content="Fernando Mayer" />
    <script src="03_RNG_inversa_files/header-attrs-2.8.6/header-attrs.js"></script>
    <link href="03_RNG_inversa_files/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="03_RNG_inversa_files/tachyons-4.12.0/tachyons.min.css" rel="stylesheet" />
    <!-- https://github.com/garthtarr/sydney_xaringan -->

    <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
         TeX: { equationNumbers: { autoNumber: "AMS" } },
     });
    </script>
    <style>
     .mjx-mrow a {
         color: black;
         pointer-events: none;
         cursor: default;
     }
    </style>
    <link rel="stylesheet" href="config/sydney.css" type="text/css" />
    <link rel="stylesheet" href="config/sydney-fonts.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Geração de números aleatórios não uniformes
## Método da transformação integral de probabilidade
### Fernando Mayer
### 2019-09-10 .footnotesize[(última atualização 2021-06-10)]

---




# Introdução

- A GNA Uniformes são o ponto de partida para GNA de outras
distribuições.

- Do ponto de vista de simulação computacional, é importante
gerar números das distribuições de probabilidade mais comuns.

- Também é importante saber gerar números de distribuições desconhecidas
  ou da qual se sabe apenas seu núcleo

#### Objetivos

- Mostrar a GNA de VAs contínusa e discretas

- Apresentar o método da transformação integral de probabilidades

---
# Distribuição uniforme: propriedades

Se `\(X \sim \text{U}(a, b)\)`, então sua função de densidade é

$$
f(x; a, b) = \frac{1}{b - a} \cdot I(a \leq x &lt; b), \quad -\infty &lt; a &lt;
b &lt; \infty.
$$

A função de distribuição é

$$
F(x; a, b) = \Pr(X &lt; x) = \int_{-\infty}^{x} f(x, a, b)\, \text{d}x =
`\begin{cases}
0, &amp; x &lt; a \\
\dfrac{x - a}{b - a}, &amp; a \leq x &lt; b\\
1, &amp; x \geq b.
\end{cases}`
$$

#### Caso particular: `\(X \sim \text{U}(0, 1)\)`

$$
f(x) = 1, \quad 0 &lt; x &lt; 1
$$

$$
F(x) =
`\begin{cases}
0, &amp; x &lt; 0 \\
x, &amp; 0 \leq x &lt; 1\\
1, &amp; x \geq b.
\end{cases}`
$$

---
# Distribuição uniforme: propriedades


```r
x &lt;- seq(0, 1, 0.01)
fx &lt;- dunif(x)
par(mfrow = c(1, 2))
plot(x, fx, type = "l")
plot(ecdf(x))
par(mfrow = c(1, 1))
```

&lt;img src="figures/03_RNG_inversa/unnamed-chunk-2-1.png" width="50%" style="display: block; margin: auto;" /&gt;

---
# Transformação integral de probabilidade

#### Definição (Transformação Integral de Probabilidade)

&lt;!-- Mood, pg. 202; Casella e Berger, pg. 49 --&gt;

.content-box-yellow[
(a) Se `\(X\)` é uma variável aleatória com função de distribuição acumulada
`\(F_X(x)\)`, então `\(U = F_X(X)\)` é uniformemente distribuída no intervalo
`\((0,1)\)`, isto é, `\(P[U \leq u] = u\)`, `\(0 &lt; u &lt; 1\)`.
]

.content-box-purple[
(b) Se `\(U\)` é uniformemente distribuída mo intervalo `\((0,1)\)`, então
`\(X = F_{X}^{-1}(U)\)` possui função de distribuição acumulada
`\(F_X(\cdot)\)`.
]

#### Demonstração

.pull-left[
Parte (a)
$$
`\begin{align*}
P[U \leq u] &amp;= P[F_X(X) \leq u] \\
 &amp;= P[F_{X}^{-1}(F_X(X)) \leq F_{X}^{-1}(u)] \\
 &amp;= P[X \leq F_{X}^{-1}(u)] \\
 &amp;= F_X(F_{X}^{-1}(u)) \\
 &amp;= u
\end{align*}`
$$
]

.pull-right[
Parte (b)
$$
`\begin{align*}
P[X \leq x] &amp;= P[F_X^{-1}(U) \leq x] \\
 &amp;= P[F_{X}(F_X^{-1}(U)) \leq F_{X}(x)] \\
 &amp;= P[U \leq F_{X}(x)] \\
 &amp;= F_X(x)
\end{align*}`
$$
]

---
# Transformação integral de probabilidade

#### Observação

Se `\(F_X\)` for estritamente crescente, então `\(F_X^{-1}\)` é bem definida
por
$$
F_X^{-1}(u) = x \quad \Longleftrightarrow \quad F_X(x) = u.
$$
No entanto, por definição, `\(F_X\)` pode ser não decrescente (constante em
algum intervalo), então `\(F_X^{-1}\)` não é bem definida.

Considere que, se `\(x_1\)` e `\(x_2\)`, `\(x_1 &lt; x_2\)`, são os limites (inferior e
superior, respectivamente) da parte não descrescente de uma função,
então qualquer `\(x\)` que satisfaça `\(x_1 \leq x \leq x_2\)` satisfaz
`\(F_X(x) = u\)`. Esse problema é evitado definindo `\(F_X^{-1}(u)\)` para
`\(0 &lt; u &lt; 1\)` por
$$
F_X^{-1}(u) = \inf \\{ x \, : \, F_X(x) \geq u \\}
$$
ou seja, o menor valor (ínfimo) de `\(x\)` no subconjunto de valores
formados por `\(F_X(x) \geq u\)`. Dessa forma, por essa definição, se houver
um `\(x\)` que satisfaça `\(x_1 \leq x \leq x_2\)`, então `\(F_X^{-1}(u) = x_1\)`.

&lt;!-- Tem que ter os graficos aqui!!! --&gt;



---
# Transformação integral de probabilidade

- Como `\(F_X^{-1}(u) = x\)`, então `\(F_X^{-1}(u)\)` possui a mesma
  distribuição de `\(X\)`

- Portanto, para gerar um valor aleatório de `\(X\)`, determine
`\(u \sim \text{U}(0,1)\)` e calcule a inversa `\(F_X^{-1}(u)\)`

- O método é de fácil implementação, desde que `\(F_X^{-1}(u)\)` seja fácil
  de ser determinada

- O método serve para gerar variáveis contínuas ou discretas.

#### Resumindo:

1. Determine a função inversa `\(F_X^{-1}(u)\)`
2. Escreva um comando ou função para calcular `\(F_X^{-1}(u)\)`
3. Para cada valor aleatório a ser gerado:
  - (a) Obtenha um valor aleatório `\(u\)` de `\(\text{U}(0,1)\)`
  - (b) Calcule `\(x = F_X^{-1}(u)\)`

---
class: inverse, middle
# Variáveis contínuas


---
# Variáveis contínuas

Considere a seguinte distribuição de probabilidade:

$$
f(x) = 3x^2, \quad 0 &lt; x &lt; 1
$$

A função de distribuição é

$$
F(x) = \int_0^x 3v^2\, dv = x^3
$$

A inversa é

$$
u = x^3 \quad \Rightarrow \quad x = u^{1/3} = F_X^{-1}(u)
$$

Uma implemantação simples seria


```r
## Gera 1000 valores da uniforme
n &lt;- 1000
u &lt;- runif(n)
## Calcula a inversa
x &lt;- u^(1/3)
```

---
# Variáveis contínuas

.pull-left[

```r
## Histograma dos valores gerados
hist(x, prob = TRUE)
## Modelo teórico
curve(3 * x^2, from = 0, to = 1, add = TRUE, col = 2)
```

&lt;img src="figures/03_RNG_inversa/unnamed-chunk-5-1.png" width="90%" style="display: block; margin: auto;" /&gt;
]
.pull-right[

```r
## Acumulada empírica
plot(ecdf(x))
## Acumulada teórica
curve(x^3, from = 0, to = 1, add = TRUE, col = 2)
legend("left", legend = c("Empírica", "Teórica"),
       lty = 1, col = 1:2, bty = "n")
```

&lt;img src="figures/03_RNG_inversa/unnamed-chunk-6-1.png" width="90%" style="display: block; margin: auto;" /&gt;
]

---
# Variáveis contínuas

#### Exponencial

.pull-left-70[
Uma v.a. `\(X\)` segue o **modelo exponencial** com parâmetro `\(\lambda &gt; 0\)`
se sua densidade é dada por
$$
f(x) = \lambda e^{-\lambda x} \cdot I(x &gt; 0),
$$

sendo `\(\lambda &gt; 0\)`. Denota-se por `\(X \sim \text{Exp}(\lambda)\)`.

A função de distribuição da Exponencial é
$$
F(x) = \int_{0}^{x} f(v)\, \text{d}v = 1 - \exp\{(-\lambda x)\}.
$$

Dessa forma, a inversa de `\(F(x)\)` é
$$
`\begin{align*}
u &amp;= 1 - \exp\{-\lambda x\}\\
1 - u &amp;= \exp\{-\lambda x\}\\
\log(1 - u) &amp;= -\lambda x\\
-\frac{\log(1 - u)}{\lambda} &amp;= x\\
\therefore \quad x &amp;= F^{-1}(u) = -\frac{\log(1 - u)}{\lambda}.
\end{align*}`
$$
]
.pull-right-30[
#### Implementação em R


```r
randexp &lt;- function(n, lambda) {
    u &lt;- runif(n)
    x &lt;- -log(1 - u)/lambda
    return(x)
}
```
]

---
# Variáveis contínuas

.pull-left.code80[

```r
*x &lt;- randexp(n = 1000, lambda = 0.5)
hist(x, freq = FALSE)
curve(dexp(x, rate = 0.5), add = TRUE, col = 2, from = 0)
```

&lt;img src="figures/03_RNG_inversa/unnamed-chunk-8-1.png" width="90%" style="display: block; margin: auto;" /&gt;
]
.pull-right.code80[

```r
plot(ecdf(x))
Fx &lt;- function(x, lambda) 1 - exp(-lambda * x)
curve(Fx(x, lambda = 0.5), add = TRUE, col = 2, from = 0)
## curve(pexp(x, rate = 0.5), add = TRUE, col = 2, from = 0)
plot(ecdf(rexp(x, rate = 0.5)), add = TRUE, col = 3)
legend("right", legend = c("Empírica", "Teórica", "rexp"),
       lty = 1, col = 1:3, bty = "n")
```

&lt;img src="figures/03_RNG_inversa/unnamed-chunk-9-1.png" width="90%" style="display: block; margin: auto;" /&gt;
]

---
# Variáveis contínuas

#### Uniforme no intervalo `\([a,b]\)`

.pull-left-70[
Se `\(X \sim U[a,b]\)` então
$$
f(x) = \frac{1}{b - a}, \quad  a \leq x \leq b
$$
Sua função de distribuição é
$$
F(x) = \int_{a}^{x} f(v)\, \text{d}v = \frac{x-a}{b-a}, \quad
a \leq x \leq b
$$
Sua inversa é
$$
u = \frac{x-a}{b-a} \quad \Rightarrow \quad
x = a + (b-1)u
$$
]
.pull-right-30[

```r
randunif &lt;- function(n, a, b) {
    u &lt;- runif(n)
    x &lt;- a + (b - 1) * u
    return(x)
}
```
]

---
# Variáveis contínuas

#### Uniforme no intervalo `\([a,b]\)`

.pull-left.code80[

```r
*x &lt;- randunif(n = 1000, a = 1, b = 10)
hist(x, freq = FALSE)
curve(dunif(x, 1, 10), add = TRUE, col = 2, from = 1)
```

&lt;img src="figures/03_RNG_inversa/unnamed-chunk-11-1.png" width="90%" style="display: block; margin: auto;" /&gt;
]
.pull-right.code80[

```r
plot(ecdf(x))
Fx &lt;- function(x, a, b) (x - a)/(b - a)
curve(Fx(x, a = 1, b = 10), add = TRUE, col = 2,
      from = 1, to = 10)
## curve(punif(x, 1, 10), add = TRUE, col = 2, from = 1, to = 10)
plot(ecdf(runif(x, 1, 10)), add = TRUE, col = 3)
legend("right", legend = c("Empírica", "Teórica", "runif"),
       lty = 1, col = 1:3, bty = "n")
```

&lt;img src="figures/03_RNG_inversa/unnamed-chunk-12-1.png" width="90%" style="display: block; margin: auto;" /&gt;
]

---
# Variáveis contínuas

#### Gama

.pull-left[
Se `\(X \sim G[r,\lambda]\)` então
$$
f(x) = \frac{1}{\Gamma(r)\lambda^r} x^{r-1} e^{\frac{x}{\lambda}},
\quad  x &gt; 0
$$
Sua função de distribuição é
$$
F(x) = \int_{0}^{x} f(v)\, \text{d}v =
\frac{1}{\Gamma(r)} \gamma \left(r, \frac{x}{\lambda} \right)
$$
Sua inversa é
$$
u = \frac{1}{\Gamma(r)} \gamma \left(r, \frac{x}{\lambda} \right)
\quad \Rightarrow \quad
x = \frac{u^{-(r+1)}}{\Gamma(r)\lambda^r}e^{-u/\lambda}
$$
Onde `\(\gamma(\cdot)\)` é a [função gama
incompleta](https://en.wikipedia.org/wiki/Incomplete_gamma_function).
]
.pull-right.code80[

```r
randgama &lt;- function(n, r, lambda) {
    u &lt;- runif(n)
    x &lt;- (u^(-(r + 1))/(gamma(r) * lambda^r)) * exp(-u/lambda)
    return(x)
}
```
]

---
exclude: true
# Variáveis contínuas

#### Gama

.pull-left.code80[

```r
xx &lt;- rgamma(1000, 1, 2)
hist(xx)
```

&lt;img src="figures/03_RNG_inversa/unnamed-chunk-14-1.png" width="90%" style="display: block; margin: auto;" /&gt;

```r
*x &lt;- randgama(n = 1000, r = 1/200, lambda = 1/200)
hist(x, freq = FALSE)
curve(dunif(x, 1, 10), add = TRUE, col = 2, from = 1)
```

&lt;img src="figures/03_RNG_inversa/unnamed-chunk-14-2.png" width="90%" style="display: block; margin: auto;" /&gt;
]
.pull-right.code80[

```r
plot(ecdf(x))
Fx &lt;- function(x, a, b) (x - a)/(b - a)
curve(Fx(x, a = 1, b = 10), add = TRUE, col = 2,
      from = 1, to = 10)
## curve(punif(x, 1, 10), add = TRUE, col = 2, from = 1, to = 10)
plot(ecdf(runif(x, 1, 10)), add = TRUE, col = 3)
legend("right", legend = c("Empírica", "Teórica", "runif"),
       lty = 1, col = 1:3, bty = "n")
```

&lt;img src="figures/03_RNG_inversa/unnamed-chunk-15-1.png" width="90%" style="display: block; margin: auto;" /&gt;
]

---
class: inverse, middle
# Variáveis discretas

---
# Variáveis discretas

A GNA de VAs discretas é feito por busca direta no intervalo ao qual o
valor uniforme pertence na distribuição acumulada.

Se `\(X\)` é uma VA discreta e

$$
`\begin{align}
\ldots &lt; x_{i-1} &lt; x_i &lt; x_{i+1} &lt; \ldots
\end{align}`
$$

são os **pontos de descontinuidade** de `\(F_X(x)\)`, então a transformação
inversa é

$$
`\begin{align}
F_X^{-1}(u) = x_i, \quad \text{ onde } \quad
F_X(x_{i-1}) &lt; u \leq F_X(x_{i})
\end{align}`
$$

Portanto, para cada valor:

1. Gere `\(u\)` de `\(U(0,1)\)`
2. Define `\(x_i\)` onde `\(F_X(x_{i-1}) &lt; u \leq F_X(x_{i})\)`

**Obs.:** o passo 2 pode ser difícil para algumas distribuições.

---
# Variáveis discretas

#### Bernoulli

.pull-left[
Se `\(X \sim Ber(p)\)` então
$$
P(X=x) = p^x (1-p)^{n-x}, \quad  x=0,1
$$
Sua função de distribuição é
$$
F_X(x) =
`\begin{cases}
1-p, &amp; x = 0 \\
1,   &amp; x = 1
\end{cases}`
$$
Portanto, se `\(p=0.4\)`, por exemplo,
$$
F_X^{-1}(u) =
`\begin{cases}
1, &amp; u &gt; 0.6 \\
0,   &amp; u \leq 0.6
\end{cases}`
$$
]
.pull-right[

```r
p &lt;- 0.4; q &lt;- 1 - p
x &lt;- rbinom(1000, size = 1, prob = p)
plot(ecdf(x), verticals = TRUE, col.vert = "red")
```

&lt;img src="figures/03_RNG_inversa/unnamed-chunk-16-1.png" width="90%" style="display: block; margin: auto;" /&gt;
]

---
# Variáveis discretas

#### Bernoulli

.pull-left[

```r
## Uma implementação elegante
n &lt;- 1000
u &lt;- runif(n)
*x &lt;- as.integer(u &gt; 0.6)
```

```r
## Uma forma mais longa (e menos eficiente)
x2 &lt;- integer(n)
p &lt;- 0.4
q &lt;- 1 - p
for(i in 1:length(x2)) {
    if(u[i] &lt; q) {
        x2[i] &lt;- 0L
    } else {
        x2[i] &lt;- 1L
    }
}
identical(x, x2)
```

```
# [1] TRUE
```
]

.pull-right[

```r
## Usando ifelse vetorizado
x3 &lt;- ifelse(u &lt; q, 0L, 1L)
identical(x2, x3)
```

```
# [1] TRUE
```

```r
## Usando seleção condicional
x4 &lt;- integer(n)
x4[u &gt;= q] &lt;- 1L
identical(x3, x4)
```

```
# [1] TRUE
```
Outras formas de gerar da Bernoulli:


```r
rbinom(n, size = 1, prob = p)
sample(c(0, 1), size = n, replace = TRUE,
       prob = c(0.6, 0.4))
```
]

---
# Variáveis discretas

#### Bernoulli

.pull-left.code80[

```r
addmargins(prop.table(table(x)))
```

```
# x
#   0   1 Sum 
# 0.6 0.4 1.0
```

```r
barplot(prop.table(table(x)), ylim = c(0, 0.7))
```

&lt;img src="figures/03_RNG_inversa/unnamed-chunk-21-1.png" width="90%" style="display: block; margin: auto;" /&gt;
]
.pull-right.code80[

```r
plot(ecdf(x))
curve(pbinom(x, size = 1, p = p), add = TRUE, type = "s", col = 2)
plot(ecdf(rbinom(x, size = 1, prob = p)), add = TRUE, col = 3)
legend("right", legend = c("Empírica", "Teórica", "rbinom"),
       lty = 1, col = 1:3, bty = "n")
```

&lt;img src="figures/03_RNG_inversa/unnamed-chunk-22-1.png" width="90%" style="display: block; margin: auto;" /&gt;
]

---
# Variáveis discretas

#### Uniforme discreta

.pull-left[
Se `\(X\)` tem distribuição uniforme discreta com `\(k\)` valores, o seu
suporte é o conjunto `\(x \in \{1, 2, \ldots, k\}\)`, `\(k \geq 2\)`. A função
de probabilidade é
$$
p(x) = \frac{1}{k} \cdot I(x \in \{1, 2, \ldots, k\}).
$$

A função de probabilidade acumulada é
$$
F(x) = \frac{x}{k}.
$$

Gera-se números da VA uniforme `\(U \sim \text{U}(0, 1)\)` e obtém-se
números da VA `\(X\)` de distribuição uniforme discreta usando

$$
X =
`\begin{cases}
1, &amp; \text{se } U &lt; 1/k \\
2, &amp; \text{se } 1/k \leq U &lt; 2/k \\
\vdots &amp; \vdots \\
k, &amp; \text{se } (k-1)/k \leq U &lt; 1. \\
\end{cases}`
$$
]
.pull-right[
Um exemplo com `\(X \sim \text{U}(k=10)\)`

```r
x &lt;- sample(1:10, size = 1000, replace = TRUE)
plot(ecdf(x), verticals = TRUE, col.vert = "red")
```

&lt;img src="figures/03_RNG_inversa/unnamed-chunk-23-1.png" width="90%" style="display: block; margin: auto;" /&gt;
]

---
# Variáveis discretas

#### Uniforme discreta

Uma implementação "ingênua" seria


```r
n &lt;- 1000
*u &lt;- runif(n)
x &lt;- integer(n)
k &lt;- 10
x[u &lt; 1/k] &lt;- 1
x[u &gt;= 1/k &amp; u &lt; 2/k] &lt;- 2
## Seria muito trabalhoso
```

Uma implementação usando conceitos de objetos do R


```r
xc &lt;- cut(u, breaks = c(0, seq(1/k, (k-1)/k, 0.1), k/k),
          include.lowest = TRUE)
table(xc)
```

```
# xc
#   [0,0.1] (0.1,0.2] (0.2,0.3] (0.3,0.4] (0.4,0.5] (0.5,0.6] (0.6,0.7] (0.7,0.8] 
#        96       105        98        98        98        90       116        92 
# (0.8,0.9]   (0.9,1] 
#       101       106
```

```r
*x &lt;- as.integer(xc)
```

---
# Variáveis discretas

#### Uniforme discreta

.pull-left.code80[

```r
addmargins(prop.table(table(x)))
```

```
# x
#     1     2     3     4     5     6     7     8     9    10   Sum 
# 0.096 0.105 0.098 0.098 0.098 0.090 0.116 0.092 0.101 0.106 1.000
```

```r
barplot(prop.table(table(x)), ylim = c(0, 0.15))
```

&lt;img src="figures/03_RNG_inversa/unnamed-chunk-26-1.png" width="90%" style="display: block; margin: auto;" /&gt;
]
.pull-right.code80[

```r
plot(ecdf(x))
Fx &lt;- function(x, k) x/k
curve(Fx(x, k = 10), add = TRUE, col = 2, from = 1, to = 10, n = 10, type = "s")
plot(ecdf(sample(1:10, size = 1000, replace = TRUE)), add = TRUE, col = 3)
legend("right", legend = c("Empírica", "Teórica", "sample"),
       lty = 1, col = 1:3, bty = "n")
```

&lt;img src="figures/03_RNG_inversa/unnamed-chunk-27-1.png" width="90%" style="display: block; margin: auto;" /&gt;
]

---
# Variáveis discretas

### Algoritmo de busca sequêncial

Uma forma mais geral de gerar valores aleatórios de **qualquer**
distribuição discreta.

Defina o vetor `\(p\)` de probabilidades (implicita ou explicitamente) e
gere `\(u \sim U(0,1)\)`. Com isso, faça:

1. Atribua `\(x_0 = 1\)`, `\(p_0 = P[X = x_0]\)` e `\(F(x) = p_0\)`
2. Enquanto `\(u &gt; F(x)\)` faça:
  - `\(x = x+1\)`
  - `\(F(x) = F(x) + p_x\)`
3. Retorne `\(x\)`

---
# Variáveis discretas

### Algoritmo de busca sequêncial

No caso da distribuição Uniforme discreta acima, com `\(k=10\)`, o algoritmo
seria então

1. Atribua `\(x_0 = 1\)`, `\(p_0 = P[X = x_0] = 1/10 = 0.1\)` e `\(F(x) = p_0\)`
2. Enquanto `\(u &gt; F(x)\)` faça:
  - `\(x = x+1\)`
  - `\(F(x) = F(x) + p_x\)`
3. Retorne `\(x\)`

Uma implementação básica seria


```r
randd &lt;- function(x, px) {
    u &lt;- runif(1)
    x &lt;- 1
    Fx &lt;- px[x]
    while(u &gt; Fx) {
        x &lt;- x + 1
        Fx &lt;- Fx + px[x]
    }
    return(x)
}
```

---
# Variáveis discretas

### Algoritmo de busca sequêncial

Note que esse algoritmo possui três "restrições"
- O vetor de probabilidades `\(p\)` deve ser passado explicitamente
- Gera apenas valores de VAs que começam em 1
- Gera apenas **uma realização** da variável aleatória


```r
k &lt;- 10
x &lt;- 1:k
px &lt;- rep(1/k, length(x))
randd(x = x, px = px)
```

```
# [1] 5
```

Para gerar mais valores podemos usar a função `replicate()`


```r
replicate(n = 10, randd(x = x, px = px))
```

```
#  [1] 5 3 7 8 9 1 7 3 2 6
```

---
# Variáveis discretas

Considere a seguinte distribuição


```r
x &lt;- 1:4
px &lt;- c(.2, .15, .25, .4)
plot(cumsum(px), type = "s", ylim = c(0, 1))
```

&lt;img src="figures/03_RNG_inversa/unnamed-chunk-31-1.png" width="45%" style="display: block; margin: auto;" /&gt;

---
# Variáveis discretas

Para gerar valores aleatórios desta distribuição, podemos usar a mesma
função definida acima, apenas passando os vetores de `\(X\)` e `\(p_x\)`
adequados.


```r
randd(x = x, px = px)
```

```
# [1] 1
```

```r
xr &lt;- replicate(n = 10000, randd(x = x, px = px))
plot(ecdf(xr)); lines(x, cumsum(px), type = "s", col = 2)
```

&lt;img src="figures/03_RNG_inversa/unnamed-chunk-32-1.png" width="40%" style="display: block; margin: auto;" /&gt;

---
# Variáveis discretas

#### Algoritmo de busca sequencial - Poisson

- No caso de uma distribuição como a Poisson, a aplicação direta deste
  algoritmo não é possível pois:
  - A Poisson assume um número infinito de valores discretos
  ( `\(0, 1, 2, \ldots\)` )
  - As probbailidades dependem do parâmetro da distribuição

- Assim, não é possível definir previamente os valores de `\(X\)` e `\(p_x\)`

- Uma solução seria então calcular as probabilidades implicitamente
  através de alguma forma de **recursão**

---
# Variáveis discretas

#### Algoritmo de busca sequencial - Poisson

Sabendo que

$$
P[X=x] = \frac{e^{-\lambda}\lambda^x}{x!}
$$

Então podemos determinar a probabilidade de `\(x+1\)` como sendo

$$
`\begin{align*}
P[X = x+1] &amp;= \frac{e^{-\lambda}\lambda^{x+1}}{(x+1)!} \\
  &amp;= \frac{e^{-\lambda}\lambda^{x}\lambda}{(x+1)x!} \\
  &amp;= \frac{e^{-\lambda}\lambda^{x}}{x!} \frac{\lambda}{(x+1)} \\
  &amp;= P[X=x] \frac{\lambda}{(x+1)} \\
\end{align*}`
$$

Dessa forma, podemos usar essa **atualização de probabilidade
recursiva** no algoritmo de busca sequencial.

---
# Variáveis discretas

#### Algoritmo de busca sequêncial - Poisson

Uma adaptação do algoritmo geral para a Poisson seria então

1. Gera `\(u \sim U(0,1)\)`
2. Atribua `\(x_0 = 0\)`, `\(p_0 = P[X = x_0]\)`, `\(F(x) = p_0\)` e `\(p=p_0\)`
2. Enquanto `\(u &gt; F(x)\)` faça:
  - `\(x = x+1\)`
  - `\(p = \frac{\lambda}{x} p\)`
  - `\(F(x) = F(x) + p\)`
3. Retorne `\(x\)`


```r
randpois &lt;- function(lambda) {
    u &lt;- runif(1)
    x &lt;- 0
    p0 &lt;- exp(-lambda)
    Fx &lt;- p0
    p &lt;- p0
    while(u &gt; Fx) {
        x &lt;- x + 1
        p &lt;- (lambda/x) * p
        Fx &lt;- Fx + p
    }
    return(x)
}
```

---
# Variáveis discretas

.pull-left[

```r
randpois(lambda = 5)
```

```
# [1] 8
```

```r
replicate(10, randpois(lambda = 5))
```

```
#  [1] 4 6 9 5 7 8 7 3 8 3
```

```r
x &lt;- replicate(10000, randpois(lambda = 5))
```
]
.pull-right[

```r
plot(ecdf(x))
plot(ecdf(rpois(x, lambda = 5)), add = TRUE, col = 2)
curve(ppois(x, lambda = 5), add = TRUE, type = "s", col = 3)
```

&lt;img src="figures/03_RNG_inversa/unnamed-chunk-35-1.png" width="90%" style="display: block; margin: auto;" /&gt;
]

---
# Exercícios

- Gerar valores aleatórios das distribuições **contínuas** especificadas
abaixo
  - `\(F(x) = 1-(x-1)^{2}, \quad 0 &lt; x &lt; 1.\)`
  - `\(F(x) = x^{\theta}, \quad 0 &lt; x &lt; 1, \theta &gt; 1.\)`
  - `\(F(x) = 1-\exp\{-x^2/2\tau^2\}, \quad x &gt; 0, \tau &gt; 0.\)`
  - `\(f(x) = \frac{1}{2} \sin(x), \quad 0 &lt; x &lt; \pi.\)`
  - `\(f(x) = \frac{\sec^2(x)}{\sqrt{3}} , \quad 0 &lt; x &lt; \pi/3.\)`

&gt; Dica: use programas de matemática simbólica para verificar os
resultados. Wolfram Alpha: &lt;http://www.wolframalpha.com/&gt;.

- Implemente o algoritmo de busca sequencial para gerar valores de uma
distribuição binomial.
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"ratio": "16:9",
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
